<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Get started creating and invoking Lambda functions using an AWS SDK - AWS Lambda</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="example_lambda_Scenario_GettingStartedFunctions_section" /><meta name="default_state" content="example_lambda_Scenario_GettingStartedFunctions_section" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" /><meta name="description" content="Get started creating and invoking Lambda functions using an AWS SDK" /><meta name="deployment_region" content="IAD" /><meta name="product" content="AWS Lambda" /><meta name="guide" content="Developer Guide" /><meta name="abstract" content="" /><meta name="guide-locale" content="en_us" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" hreflang="x-default" /><meta name="feedback-item" content="Lambda" /><meta name="this_doc_product" content="AWS Lambda" /><meta name="this_doc_guide" content="Developer Guide" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'lambda'}"></script><meta id="panorama-serviceSubSection" value="Developer Guide" /><meta id="panorama-serviceConsolePage" value="Get started creating and invoking Lambda functions using an AWS SDK" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Get started creating and invoking Lambda functions using an AWS SDK - AWS Lambda</title><meta name="pdf" content="/pdfs/lambda/latest/dg/lambda-dg.pdf#example_lambda_Scenario_GettingStartedFunctions_section" /><meta name="rss" content="lambda-updates.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=186" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Lambda&amp;topic_url=http://docs.aws.amazon.com/en_us/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=http://docs.aws.amazon.com/en_us/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=http://docs.aws.amazon.com/en_us/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html" /><meta name="keywords" content="Lambda,AWS Lambda,serverless,serverless applications,cloud computing,code example,AWS SDK,Get started creating and invoking Lambda functions using an AWS SDK" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "AWS Lambda",
        "item" : "https://docs.aws.amazon.com/lambda/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Developer Guide",
        "item" : "https://docs.aws.amazon.com/lambda/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Code examples for Lambda using AWS SDKs",
        "item" : "https://docs.aws.amazon.com/lambda/latest/dg/service_code_examples.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Scenarios for Lambda using AWS SDKs",
        "item" : "https://docs.aws.amazon.com/lambda/latest/dg/service_code_examples_scenarios.html"
      },
      {
        "@type" : "ListItem",
        "position" : 6,
        "name" : "Get started creating and invoking Lambda functions using an AWS SDK",
        "item" : "https://docs.aws.amazon.com/lambda/latest/dg/service_code_examples_scenarios.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="/pdfs/lambda/latest/dg/lambda-dg.pdf#example_lambda_Scenario_GettingStartedFunctions_section" target="_blank" rel="noopener noreferrer" title="Open PDF"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Documentation</a><a href="/lambda/index.html">AWS Lambda</a><a href="welcome.html">Developer Guide</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="example_lambda_Scenario_GettingStartedFunctions_section">Get started creating and invoking Lambda functions using an AWS SDK</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p>The following code examples show how to:</p><div class="itemizedlist">
     
     
     
     
     
<ul class="itemizedlist"><li class="listitem"><p>Create an IAM role and Lambda function, then upload handler code.</p></li><li class="listitem"><p>Invoke the function with a single parameter and get results.</p></li><li class="listitem"><p>Update the function code and configure with an environment variable.</p></li><li class="listitem"><p>Invoke the function with new parameters and get results. Display the returned execution log.</p></li><li class="listitem"><p>List the functions for your account, then clean up resources.</p></li></ul></div><p>For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/getting-started-create-function.html">Create a Lambda function with the console</a>.</p><awsdocs-tabs><dl style="display: none">
    <dt>.NET</dt><dd tab-id=".net">
            <div class="variablelist">
     
<dl>
        <dt><b><span class="term">AWS SDK for .NET</span></b></dt>
        <dd>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>
                    There's more on GitHub. Find the complete example and learn how to set up and run in the
                    <a href="https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/dotnetv3/Lambda#code-examples" rel="noopener noreferrer" target="_blank"><span>AWS Code Examples Repository</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>.
                </p></div></div>
             
                <p>Create methods that perform Lambda actions.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="csharp ">namespace LambdaActions;

using Amazon.Lambda;
using Amazon.Lambda.Model;

/// &lt;summary&gt;
/// A class that implements AWS Lambda methods.
/// &lt;/summary&gt;
public class LambdaWrapper
<span>{</span>
    private readonly IAmazonLambda _lambdaService;

    /// &lt;summary&gt;
    /// Constructor for the LambdaWrapper class.
    /// &lt;/summary&gt;
    /// &lt;param name="lambdaService"&gt;An initialized Lambda service client.&lt;/param&gt;
    public LambdaWrapper(IAmazonLambda lambdaService)
    <span>{</span>
        _lambdaService = lambdaService;
    }

    /// &lt;summary&gt;
    /// Creates a new Lambda function.
    /// &lt;/summary&gt;
    /// &lt;param name="functionName"&gt;The name of the function.&lt;/param&gt;
    /// &lt;param name="s3Bucket"&gt;The Amazon Simple Storage Service (Amazon S3)
    /// bucket where the zip file containing the code is located.&lt;/param&gt;
    /// &lt;param name="s3Key"&gt;The Amazon S3 key of the zip file.&lt;/param&gt;
    /// &lt;param name="role"&gt;The Amazon Resource Name (ARN) of a role with the
    /// appropriate Lambda permissions.&lt;/param&gt;
    /// &lt;param name="handler"&gt;The name of the handler function.&lt;/param&gt;
    /// &lt;returns&gt;The Amazon Resource Name (ARN) of the newly created
    /// Lambda function.&lt;/returns&gt;
    public async Task&lt;string&gt; CreateLambdaFunctionAsync(
        string functionName,
        string s3Bucket,
        string s3Key,
        string role,
        string handler)
    <span>{</span>
        // Defines the location for the function code.
        // S3Bucket - The S3 bucket where the file containing
        //            the source code is stored.
        // S3Key    - The name of the file containing the code.
        var functionCode = new FunctionCode
        <span>{</span>
            S3Bucket = s3Bucket,
            S3Key = s3Key,
        };

        var createFunctionRequest = new CreateFunctionRequest
        <span>{</span>
            FunctionName = functionName,
            Description = "Created by the Lambda .NET API",
            Code = functionCode,
            Handler = handler,
            Runtime = Runtime.Dotnet6,
            Role = role,
        };

        var reponse = await _lambdaService.CreateFunctionAsync(createFunctionRequest);
        return reponse.FunctionArn;
    }


    /// &lt;summary&gt;
    /// Delete an AWS Lambda function.
    /// &lt;/summary&gt;
    /// &lt;param name="functionName"&gt;The name of the Lambda function to
    /// delete.&lt;/param&gt;
    /// &lt;returns&gt;A Boolean value that indicates the success of the action.&lt;/returns&gt;
    public async Task&lt;bool&gt; DeleteFunctionAsync(string functionName)
    <span>{</span>
        var request = new DeleteFunctionRequest
        <span>{</span>
            FunctionName = functionName,
        };

        var response = await _lambdaService.DeleteFunctionAsync(request);

        // A return value of NoContent means that the request was processed.
        // In this case, the function was deleted, and the return value
        // is intentionally blank.
        return response.HttpStatusCode == System.Net.HttpStatusCode.NoContent;
    }


    /// &lt;summary&gt;
    /// Gets information about a Lambda function.
    /// &lt;/summary&gt;
    /// &lt;param name="functionName"&gt;The name of the Lambda function for
    /// which to retrieve information.&lt;/param&gt;
    /// &lt;returns&gt;Async Task.&lt;/returns&gt;
    public async Task&lt;FunctionConfiguration&gt; GetFunctionAsync(string functionName)
    <span>{</span>
        var functionRequest = new GetFunctionRequest
        <span>{</span>
            FunctionName = functionName,
        };

        var response = await _lambdaService.GetFunctionAsync(functionRequest);
        return response.Configuration;
    }


    /// &lt;summary&gt;
    /// Invoke a Lambda function.
    /// &lt;/summary&gt;
    /// &lt;param name="functionName"&gt;The name of the Lambda function to
    /// invoke.&lt;/param
    /// &lt;param name="parameters"&gt;The parameter values that will be passed to the function.&lt;/param&gt;
    /// &lt;returns&gt;A System Threading Task.&lt;/returns&gt;
    public async Task&lt;string&gt; InvokeFunctionAsync(
        string functionName,
        string parameters)
    <span>{</span>
        var payload = parameters;
        var request = new InvokeRequest
        <span>{</span>
            FunctionName = functionName,
            Payload = payload,
        };

        var response = await _lambdaService.InvokeAsync(request);
        MemoryStream stream = response.Payload;
        string returnValue = System.Text.Encoding.UTF8.GetString(stream.ToArray());
        return returnValue;
    }


    /// &lt;summary&gt;
    /// Get a list of Lambda functions.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;A list of FunctionConfiguration objects.&lt;/returns&gt;
    public async Task&lt;List&lt;FunctionConfiguration&gt;&gt; ListFunctionsAsync()
    <span>{</span>
        var functionList = new List&lt;FunctionConfiguration&gt;();

        var functionPaginator =
            _lambdaService.Paginators.ListFunctions(new ListFunctionsRequest());
        await foreach (var function in functionPaginator.Functions)
        <span>{</span>
            functionList.Add(function);
        }

        return functionList;
    }


    /// &lt;summary&gt;
    /// Update an existing Lambda function.
    /// &lt;/summary&gt;
    /// &lt;param name="functionName"&gt;The name of the Lambda function to update.&lt;/param&gt;
    /// &lt;param name="bucketName"&gt;The bucket where the zip file containing
    /// the Lambda function code is stored.&lt;/param&gt;
    /// &lt;param name="key"&gt;The key name of the source code file.&lt;/param&gt;
    /// &lt;returns&gt;Async Task.&lt;/returns&gt;
    public async Task UpdateFunctionCodeAsync(
        string functionName,
        string bucketName,
        string key)
    <span>{</span>
        var functionCodeRequest = new UpdateFunctionCodeRequest
        <span>{</span>
            FunctionName = functionName,
            Publish = true,
            S3Bucket = bucketName,
            S3Key = key,
        };

        var response = await _lambdaService.UpdateFunctionCodeAsync(functionCodeRequest);
        Console.WriteLine($"The Function was last modified at <span>{</span>response.LastModified}.");
    }


    /// &lt;summary&gt;
    /// Update the code of a Lambda function.
    /// &lt;/summary&gt;
    /// &lt;param name="functionName"&gt;The name of the function to update.&lt;/param&gt;
    /// &lt;param name="functionHandler"&gt;The code that performs the function's actions.&lt;/param&gt;
    /// &lt;param name="environmentVariables"&gt;A dictionary of environment variables.&lt;/param&gt;
    /// &lt;returns&gt;A Boolean value indicating the success of the action.&lt;/returns&gt;
    public async Task&lt;bool&gt; UpdateFunctionConfigurationAsync(
        string functionName,
        string functionHandler,
        Dictionary&lt;string, string&gt; environmentVariables)
    <span>{</span>
        var request = new UpdateFunctionConfigurationRequest
        <span>{</span>
            Handler = functionHandler,
            FunctionName = functionName,
            Environment = new Amazon.Lambda.Model.Environment <span>{</span> Variables = environmentVariables },
        };

        var response = await _lambdaService.UpdateFunctionConfigurationAsync(request);

        Console.WriteLine(response.LastModified);

        return response.HttpStatusCode == System.Net.HttpStatusCode.OK;
    }


}


</code></pre>
             
             
                <p>Create a function that runs the scenario.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="csharp ">global using System.Threading.Tasks;
global using Amazon.IdentityManagement;
global using Amazon.Lambda;
global using LambdaActions;
global using LambdaScenarioCommon;
global using Microsoft.Extensions.DependencyInjection;
global using Microsoft.Extensions.Hosting;
global using Microsoft.Extensions.Logging;
global using Microsoft.Extensions.Logging.Console;
global using Microsoft.Extensions.Logging.Debug;


using Amazon.IdentityManagement;
using Amazon.Lambda.Model;
using Microsoft.Extensions.Configuration;

namespace LambdaBasics;

public class LambdaBasics
<span>{</span>
    private static ILogger logger = null!;

    static async Task Main(string[] args)
    <span>{</span>
        // Set up dependency injection for the Amazon service.
        using var host = Host.CreateDefaultBuilder(args)
            .ConfigureLogging(logging =&gt;
                logging.AddFilter("System", LogLevel.Debug)
                    .AddFilter&lt;DebugLoggerProvider&gt;("Microsoft", LogLevel.Information)
                    .AddFilter&lt;ConsoleLoggerProvider&gt;("Microsoft", LogLevel.Trace))
            .ConfigureServices((_, services) =&gt;
            services.AddAWSService&lt;IAmazonLambda&gt;()
            .AddAWSService&lt;IAmazonIdentityManagementService&gt;()
            .AddTransient&lt;LambdaWrapper&gt;()
            .AddTransient&lt;LambdaRoleWrapper&gt;()
            .AddTransient&lt;UIWrapper&gt;()
        )
        .Build();

        var configuration = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("settings.json") // Load test settings from .json file.
            .AddJsonFile("settings.local.json",
            true) // Optionally load local settings.
        .Build();


        logger = LoggerFactory.Create(builder =&gt; <span>{</span> builder.AddConsole(); })
            .CreateLogger&lt;LambdaBasics&gt;();

        var lambdaWrapper = host.Services.GetRequiredService&lt;LambdaWrapper&gt;();
        var lambdaRoleWrapper = host.Services.GetRequiredService&lt;LambdaRoleWrapper&gt;();
        var uiWrapper = host.Services.GetRequiredService&lt;UIWrapper&gt;();

        string functionName = configuration["FunctionName"];
        string roleName = configuration["RoleName"];
        string policyDocument = "<span>{</span>" +
            " \"Version\": \"2012-10-17\"," +
            " \"Statement\": [ " +
            "    <span>{</span>" +
            "        \"Effect\": \"Allow\"," +
            "        \"Principal\": <span>{</span>" +
            "            \"Service\": \"lambda.amazonaws.com\" " +
            "    }," +
            "        \"Action\": \"sts:AssumeRole\" " +
            "    }" +
            "]" +
        "}";

        var incrementHandler = configuration["IncrementHandler"];
        var calculatorHandler = configuration["CalculatorHandler"];
        var bucketName = configuration["BucketName"];
        var incrementKey = configuration["IncrementKey"];
        var calculatorKey = configuration["CalculatorKey"];
        var policyArn = configuration["PolicyArn"];

        uiWrapper.DisplayLambdaBasicsOverview();

        // Create the policy to use with the AWS Lambda functions and then attach the
        // policy to a new role.
        var roleArn = await lambdaRoleWrapper.CreateLambdaRoleAsync(roleName, policyDocument);

        Console.WriteLine("Waiting for role to become active.");
        uiWrapper.WaitABit(15, "Wait until the role is active before trying to use it.");

        // Attach the appropriate AWS Identity and Access Management (IAM) role policy to the new role.
        var success = await lambdaRoleWrapper.AttachLambdaRolePolicyAsync(policyArn, roleName);
        uiWrapper.WaitABit(10, "Allow time for the IAM policy to be attached to the role.");

        // Create the Lambda function using a zip file stored in an Amazon Simple Storage Service
        // (Amazon S3) bucket.
        uiWrapper.DisplayTitle("Create Lambda Function");
        Console.WriteLine($"Creating the AWS Lambda function: <span>{</span>functionName}.");
        var lambdaArn = await lambdaWrapper.CreateLambdaFunctionAsync(
            functionName,
            bucketName,
            incrementKey,
            roleArn,
            incrementHandler);

        Console.WriteLine("Waiting for the new function to be available.");
        Console.WriteLine($"The AWS Lambda ARN is <span>{</span>lambdaArn}");

        // Get the Lambda function.
        Console.WriteLine($"Getting the <span>{</span>functionName} AWS Lambda function.");
        FunctionConfiguration config;
        do
        <span>{</span>
            config = await lambdaWrapper.GetFunctionAsync(functionName);
            Console.Write(".");
        }
        while (config.State != State.Active);

        Console.WriteLine($"\nThe function, <span>{</span>functionName} has been created.");
        Console.WriteLine($"The runtime of this Lambda function is <span>{</span>config.Runtime}.");

        uiWrapper.PressEnter();

        // List the Lambda functions.
        uiWrapper.DisplayTitle("Listing all Lambda functions.");
        var functions = await lambdaWrapper.ListFunctionsAsync();
        DisplayFunctionList(functions);

        uiWrapper.DisplayTitle("Invoke increment function");
        Console.WriteLine("Now that it has been created, invoke the Lambda increment function.");
        string? value;
        do
        <span>{</span>
            Console.Write("Enter a value to increment: ");
            value = Console.ReadLine();
        }
        while (string.IsNullOrEmpty(value));

        string functionParameters = "<span>{</span>" +
            "\"action\": \"increment\", " +
            "\"x\": \"" + value + "\"" +
        "}";
        var answer = await lambdaWrapper.InvokeFunctionAsync(functionName, functionParameters);
        Console.WriteLine($"<span>{</span>value} + 1 = <span>{</span>answer}.");

        uiWrapper.DisplayTitle("Update function");
        Console.WriteLine("Now update the Lambda function code.");
        await lambdaWrapper.UpdateFunctionCodeAsync(functionName, bucketName, calculatorKey);

        do
        <span>{</span>
            config = await lambdaWrapper.GetFunctionAsync(functionName);
            Console.Write(".");
        }
        while (config.LastUpdateStatus == LastUpdateStatus.InProgress);

        await lambdaWrapper.UpdateFunctionConfigurationAsync(
            functionName,
            calculatorHandler,
            new Dictionary&lt;string, string&gt; <span>{</span> <span>{</span> "LOG_LEVEL", "DEBUG" } });

        do
        <span>{</span>
            config = await lambdaWrapper.GetFunctionAsync(functionName);
            Console.Write(".");
        }
        while (config.LastUpdateStatus == LastUpdateStatus.InProgress);

        uiWrapper.DisplayTitle("Call updated function");
        Console.WriteLine("Now call the updated function...");

        bool done = false;

        do
        <span>{</span>
            string? opSelected;

            Console.WriteLine("Select the operation to perform:");
            Console.WriteLine("\t1. add");
            Console.WriteLine("\t2. subtract");
            Console.WriteLine("\t3. multiply");
            Console.WriteLine("\t4. divide");
            Console.WriteLine("\tOr enter \"q\" to quit.");
            Console.WriteLine("Enter the number (1, 2, 3, 4, or q) of the operation you want to perform: ");
            do
            <span>{</span>
                Console.Write("Your choice? ");
                opSelected = Console.ReadLine();
            }
            while (opSelected == string.Empty);

            var operation = (opSelected) switch
            <span>{</span>
                "1" =&gt; "add",
                "2" =&gt; "subtract",
                "3" =&gt; "multiply",
                "4" =&gt; "divide",
                "q" =&gt; "quit",
                _ =&gt; "add",
            };

            if (operation == "quit")
            <span>{</span>
                done = true;
            }
            else
            <span>{</span>
                // Get two numbers and an action from the user.
                value = string.Empty;
                do
                <span>{</span>
                    Console.Write("Enter the first value: ");
                    value = Console.ReadLine();
                }
                while (value == string.Empty);

                string? value2;
                do
                <span>{</span>
                    Console.Write("Enter a second value: ");
                    value2 = Console.ReadLine();
                }
                while (value2 == string.Empty);

                functionParameters = "<span>{</span>" +
                    "\"action\": \"" + operation + "\", " +
                    "\"x\": \"" + value + "\"," +
                    "\"y\": \"" + value2 + "\"" +
                "}";

                answer = await lambdaWrapper.InvokeFunctionAsync(functionName, functionParameters);
                Console.WriteLine($"The answer when we <span>{</span>operation} the two numbers is: <span>{</span>answer}.");
            }

            uiWrapper.PressEnter();
        } while (!done);

        // Delete the function created earlier.

        uiWrapper.DisplayTitle("Clean up resources");
        // Detach the IAM policy from the IAM role.
        Console.WriteLine("First detach the IAM policy from the role.");
        success = await lambdaRoleWrapper.DetachLambdaRolePolicyAsync(policyArn, roleName);
        uiWrapper.WaitABit(15, "Let's wait for the policy to be fully detached from the role.");

        Console.WriteLine("Delete the AWS Lambda function.");
        success = await lambdaWrapper.DeleteFunctionAsync(functionName);
        if (success)
        <span>{</span>
            Console.WriteLine($"The <span>{</span>functionName} function was deleted.");
        }
        else
        <span>{</span>
            Console.WriteLine($"Could not remove the function <span>{</span>functionName}");
        }

        // Now delete the IAM role created for use with the functions
        // created by the application.
        Console.WriteLine("Now we can delete the role that we created.");
        success = await lambdaRoleWrapper.DeleteLambdaRoleAsync(roleName);
        if (success)
        <span>{</span>
            Console.WriteLine("The role has been successfully removed.");
        }
        else
        <span>{</span>
            Console.WriteLine("Couldn't delete the role.");
        }

        Console.WriteLine("The Lambda Scenario is now complete.");
        uiWrapper.PressEnter();

        // Displays a formatted list of existing functions returned by the
        // LambdaMethods.ListFunctions.
        void DisplayFunctionList(List&lt;FunctionConfiguration&gt; functions)
        <span>{</span>
            functions.ForEach(functionConfig =&gt;
            <span>{</span>
                Console.WriteLine($"<span>{</span>functionConfig.FunctionName}\t<span>{</span>functionConfig.Description}");
            });
        }
    }
}


namespace LambdaActions;

using Amazon.IdentityManagement;
using Amazon.IdentityManagement.Model;

public class LambdaRoleWrapper
<span>{</span>
    private readonly IAmazonIdentityManagementService _lambdaRoleService;

    public LambdaRoleWrapper(IAmazonIdentityManagementService lambdaRoleService)
    <span>{</span>
        _lambdaRoleService = lambdaRoleService;
    }

    /// &lt;summary&gt;
    /// Attach an AWS Identity and Access Management (IAM) role policy to the
    /// IAM role to be assumed by the AWS Lambda functions created for the scenario.
    /// &lt;/summary&gt;
    /// &lt;param name="policyArn"&gt;The Amazon Resource Name (ARN) of the IAM policy.&lt;/param&gt;
    /// &lt;param name="roleName"&gt;The name of the IAM role to attach the IAM policy to.&lt;/param&gt;
    /// &lt;returns&gt;A Boolean value indicating the success of the action.&lt;/returns&gt;
    public async Task&lt;bool&gt; AttachLambdaRolePolicyAsync(string policyArn, string roleName)
    <span>{</span>
        var response = await _lambdaRoleService.AttachRolePolicyAsync(new AttachRolePolicyRequest <span>{</span> PolicyArn = policyArn, RoleName = roleName });
        return response.HttpStatusCode == System.Net.HttpStatusCode.OK;
    }

    /// &lt;summary&gt;
    /// Create a new IAM role.
    /// &lt;/summary&gt;
    /// &lt;param name="roleName"&gt;The name of the IAM role to create.&lt;/param&gt;
    /// &lt;param name="policyDocument"&gt;The policy document for the new IAM role.&lt;/param&gt;
    /// &lt;returns&gt;A string representing the ARN for newly created role.&lt;/returns&gt;
    public async Task&lt;string&gt; CreateLambdaRoleAsync(string roleName, string policyDocument)
    <span>{</span>
        var request = new CreateRoleRequest
        <span>{</span>
            AssumeRolePolicyDocument = policyDocument,
            RoleName = roleName,
        };

        var response = await _lambdaRoleService.CreateRoleAsync(request);
        return response.Role.Arn;
    }

    /// &lt;summary&gt;
    /// Deletes an IAM role.
    /// &lt;/summary&gt;
    /// &lt;param name="roleName"&gt;The name of the role to delete.&lt;/param&gt;
    /// &lt;returns&gt;A Boolean value indicating the success of the operation.&lt;/returns&gt;
    public async Task&lt;bool&gt; DeleteLambdaRoleAsync(string roleName)
    <span>{</span>
        var request = new DeleteRoleRequest
        <span>{</span>
            RoleName = roleName,
        };

        var response = await _lambdaRoleService.DeleteRoleAsync(request);
        return response.HttpStatusCode == System.Net.HttpStatusCode.OK;
    }

    public async Task&lt;bool&gt; DetachLambdaRolePolicyAsync(string policyArn, string roleName)
    <span>{</span>
        var response = await _lambdaRoleService.DetachRolePolicyAsync(new DetachRolePolicyRequest <span>{</span> PolicyArn = policyArn, RoleName = roleName });
        return response.HttpStatusCode == System.Net.HttpStatusCode.OK;
    }
}


namespace LambdaScenarioCommon;
public class UIWrapper
<span>{</span>
    public readonly string SepBar = new('-', Console.WindowWidth);

    /// &lt;summary&gt;
    /// Show information about the AWS Lambda Basics scenario.
    /// &lt;/summary&gt;
    public void DisplayLambdaBasicsOverview()
    <span>{</span>
        Console.Clear();

        DisplayTitle("Welcome to AWS Lambda Basics");
        Console.WriteLine("This example application does the following:");
        Console.WriteLine("\t1. Creates an AWS Identity and Access Management (IAM) role that will be assumed by the functions we create.");
        Console.WriteLine("\t2. Attaches an IAM role policy that has Lambda permissions.");
        Console.WriteLine("\t3. Creates a Lambda function that increments the value passed to it.");
        Console.WriteLine("\t4. Calls the increment function and passes a value.");
        Console.WriteLine("\t5. Updates the code so that the function is a simple calculator.");
        Console.WriteLine("\t6. Calls the calculator function with the values entered.");
        Console.WriteLine("\t7. Deletes the Lambda function.");
        Console.WriteLine("\t7. Detaches the IAM role policy.");
        Console.WriteLine("\t8. Deletes the IAM role.");
        PressEnter();
    }

    /// &lt;summary&gt;
    /// Display a message and wait until the user presses enter.
    /// &lt;/summary&gt;
    public void PressEnter()
    <span>{</span>
        Console.Write("\nPress &lt;Enter&gt; to continue. ");
        _ = Console.ReadLine();
        Console.WriteLine();
    }

    /// &lt;summary&gt;
    /// Pad a string with spaces to center it on the console display.
    /// &lt;/summary&gt;
    /// &lt;param name="strToCenter"&gt;The string to be centered.&lt;/param&gt;
    /// &lt;returns&gt;The padded string.&lt;/returns&gt;
    public string CenterString(string strToCenter)
    <span>{</span>
        var padAmount = (Console.WindowWidth - strToCenter.Length) / 2;
        var leftPad = new string(' ', padAmount);
        return $"<span>{</span>leftPad}<span>{</span>strToCenter}";
    }

    /// &lt;summary&gt;
    /// Display a line of hyphens, the centered text of the title and another
    /// line of hyphens.
    /// &lt;/summary&gt;
    /// &lt;param name="strTitle"&gt;The string to be displayed.&lt;/param&gt;
    public void DisplayTitle(string strTitle)
    <span>{</span>
        Console.WriteLine(SepBar);
        Console.WriteLine(CenterString(strTitle));
        Console.WriteLine(SepBar);
    }

    /// &lt;summary&gt;
    /// Display a countdown and wait for a number of seconds.
    /// &lt;/summary&gt;
    /// &lt;param name="numSeconds"&gt;The number of seconds to wait.&lt;/param&gt;
    public void WaitABit(int numSeconds, string msg)
    <span>{</span>
        Console.WriteLine(msg);

        // Wait for the requested number of seconds.
        for (int i = numSeconds; i &gt; 0; i--)
        <span>{</span>
            System.Threading.Thread.Sleep(1000);
            Console.Write($"<span>{</span>i}...");
        }

        PressEnter();
    }
}


</code></pre>
             
             
                <p>Define a Lambda handler that increments a number.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="csharp ">using Amazon.Lambda.Core;

// Assembly attribute to enable the Lambda function's JSON input to be converted into a .NET class.
[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace LambdaIncrement;

public class Function
<span>{</span>

    /// &lt;summary&gt;
    /// A simple function increments the integer parameter.
    /// &lt;/summary&gt;
    /// &lt;param name="input"&gt;A JSON string containing an action, which must be
    /// "increment" and a string representing the value to increment.&lt;/param&gt;
    /// &lt;param name="context"&gt;The context object passed by Lambda containing
    /// information about invocation, function, and execution environment.&lt;/param&gt;
    /// &lt;returns&gt;A string representing the incremented value of the parameter.&lt;/returns&gt;
    public int FunctionHandler(Dictionary&lt;string, string&gt; input, ILambdaContext context)
    <span>{</span>
        if (input["action"] == "increment")
        <span>{</span>
            int inputValue = Convert.ToInt32(input["x"]);
            return inputValue + 1;
        }
        else
        <span>{</span>
            return 0;
        }
    }
}


</code></pre>
             
             
                <p>Define a second Lambda handler that performs arithmetic operations.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="csharp ">using System.Diagnostics;
using Amazon.Lambda.Core;

// Assembly attribute to enable the Lambda function's JSON input to be converted into a .NET class.
[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace LambdaCalculator;

public class Function
<span>{</span>

    /// &lt;summary&gt;
    /// A simple function that takes two number in string format and performs
    /// the requested arithmetic function.
    /// &lt;/summary&gt;
    /// &lt;param name="input"&gt;JSON data containing an action, and x and y values.
    /// Valid actions include: add, subtract, multiply, and divide.&lt;/param&gt;
    /// &lt;param name="context"&gt;The context object passed by Lambda containing
    /// information about invocation, function, and execution environment.&lt;/param&gt;
    /// &lt;returns&gt;A string representing the results of the calculation.&lt;/returns&gt;
    public int FunctionHandler(Dictionary&lt;string, string&gt; input, ILambdaContext context)
    <span>{</span>
        var action = input["action"];
        int x = Convert.ToInt32(input["x"]);
        int y = Convert.ToInt32(input["y"]);
        int result;
        switch (action)
        <span>{</span>
            case "add":
                result = x + y;
                break;
            case "subtract":
                result = x - y;
                break;
            case "multiply":
                result = x * y;
                break;
            case "divide":
                if (y == 0)
                <span>{</span>
                    Console.Error.WriteLine("Divide by zero error.");
                    result = 0;
                }
                else
                    result = x / y;
                break;
            default:
                Console.Error.WriteLine($"<span>{</span>action} is not a valid operation.");
                result = 0;
                break;
        }
        return result;
    }
}


</code></pre>
             
            <div class="itemizedlist">
                 
            <ul class="itemizedlist"><li class="listitem">
                    <p>For API details, see the following topics in <em>AWS SDK for .NET API Reference</em>.</p>
                    <div class="itemizedlist">
                         
                         
                         
                         
                         
                         
                         
                    <ul class="itemizedlist"><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/DotNetSDKV3/lambda-2015-03-31/CreateFunction">CreateFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/DotNetSDKV3/lambda-2015-03-31/DeleteFunction">DeleteFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/DotNetSDKV3/lambda-2015-03-31/GetFunction">GetFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/DotNetSDKV3/lambda-2015-03-31/Invoke">Invoke</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/DotNetSDKV3/lambda-2015-03-31/ListFunctions">ListFunctions</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/DotNetSDKV3/lambda-2015-03-31/UpdateFunctionCode">UpdateFunctionCode</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/DotNetSDKV3/lambda-2015-03-31/UpdateFunctionConfiguration">UpdateFunctionConfiguration</a></p></li></ul></div>
                </li></ul></div>
        </dd>
    </dl></div>
        </dd>
    <dt>C++</dt><dd tab-id="c++">
            <div class="variablelist">
     
<dl>
        <dt><b><span class="term">SDK for C++</span></b></dt>
        <dd>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>
                    There's more on GitHub. Find the complete example and learn how to set up and run in the
                    <a href="https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/cpp/example_code/lambda#code-examples" rel="noopener noreferrer" target="_blank"><span>AWS Code Examples Repository</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>.
                </p></div></div>
             
                <p></p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="cpp ">//! Get started with functions scenario.
/*!
 \param clientConfig: AWS client configuration.
 \return bool: Successful completion.
 */
bool AwsDoc::Lambda::getStartedWithFunctionsScenario(
        const Aws::Client::ClientConfiguration &amp;clientConfig) <span>{</span>

    Aws::Lambda::LambdaClient client(clientConfig);

    // 1. Create an AWS Identity and Access Management (IAM) role for Lambda function.
    Aws::String roleArn;
    if (!getIamRoleArn(roleArn, clientConfig)) <span>{</span>
        return false;
    }

    // 2. Create a Lambda function.
    int seconds = 0;
    do <span>{</span>
        Aws::Lambda::Model::CreateFunctionRequest request;
        request.SetFunctionName(LAMBDA_NAME);
        request.SetDescription(LAMBDA_DESCRIPTION); // Optional.
#if USE_CPP_LAMBDA_FUNCTION
        request.SetRuntime(Aws::Lambda::Model::Runtime::provided_al2);
        request.SetTimeout(15);
        request.SetMemorySize(128);

        // Assume the AWS Lambda function was built in Docker with same architecture
        // as this code.
#if  defined(__x86_64__)
        request.SetArchitectures(<span>{</span>Aws::Lambda::Model::Architecture::x86_64});
#elif defined(__aarch64__)
        request.SetArchitectures(<span>{</span>Aws::Lambda::Model::Architecture::arm64});
#else
#error "Unimplemented architecture"
#endif // defined(architecture)
#else
        request.SetRuntime(Aws::Lambda::Model::Runtime::python3_8);
#endif
        request.SetRole(roleArn);
        request.SetHandler(LAMBDA_HANDLER_NAME);
        request.SetPublish(true);
        Aws::Lambda::Model::FunctionCode code;
        std::ifstream ifstream(INCREMENT_LAMBDA_CODE.c_str(),
                               std::ios_base::in | std::ios_base::binary);
        if (!ifstream.is_open()) <span>{</span>
            std::cerr &lt;&lt; "Error opening file " &lt;&lt; INCREMENT_LAMBDA_CODE &lt;&lt; "." &lt;&lt; std::endl;

#if USE_CPP_LAMBDA_FUNCTION
            std::cerr
                    &lt;&lt; "The cpp Lambda function must be built following the instructions in the cpp_lambda/README.md file. "
                    &lt;&lt; std::endl;
#endif
            deleteIamRole(clientConfig);
            return false;
        }

        Aws::StringStream buffer;
        buffer &lt;&lt; ifstream.rdbuf();

        code.SetZipFile(Aws::Utils::ByteBuffer((unsigned char *) buffer.str().c_str(),
                                               buffer.str().length()));
        request.SetCode(code);

        Aws::Lambda::Model::CreateFunctionOutcome outcome = client.CreateFunction(
                request);

        if (outcome.IsSuccess()) <span>{</span>
            std::cout &lt;&lt; "The lambda function was successfully created. " &lt;&lt; seconds
                      &lt;&lt; " seconds elapsed." &lt;&lt; std::endl;
            break;
        }
        else if (outcome.GetError().GetErrorType() ==
                 Aws::Lambda::LambdaErrors::INVALID_PARAMETER_VALUE &amp;&amp;
                 outcome.GetError().GetMessage().find("role") &gt;= 0) <span>{</span>
            if ((seconds % 5) == 0) <span>{</span> // Log status every 10 seconds.
                std::cout
                        &lt;&lt; "Waiting for the IAM role to become available as a CreateFunction parameter. "
                        &lt;&lt; seconds
                        &lt;&lt; " seconds elapsed." &lt;&lt; std::endl;

                std::cout &lt;&lt; outcome.GetError().GetMessage() &lt;&lt; std::endl;
            }
        }
        else <span>{</span>
            std::cerr &lt;&lt; "Error with CreateFunction. "
                      &lt;&lt; outcome.GetError().GetMessage()
                      &lt;&lt; std::endl;
            deleteIamRole(clientConfig);
            return false;
        }
        ++seconds;
        std::this_thread::sleep_for(std::chrono::seconds(1));
    } while (60 &gt; seconds);

    std::cout &lt;&lt; "The current Lambda function increments 1 by an input." &lt;&lt; std::endl;

    // 3.  Invoke the Lambda function.
    <span>{</span>
        int increment = askQuestionForInt("Enter an increment integer: ");

        Aws::Lambda::Model::InvokeResult invokeResult;
        Aws::Utils::Json::JsonValue jsonPayload;
        jsonPayload.WithString("action", "increment");
        jsonPayload.WithInteger("number", increment);
        if (invokeLambdaFunction(jsonPayload, Aws::Lambda::Model::LogType::Tail,
                                 invokeResult, client)) <span>{</span>
            Aws::Utils::Json::JsonValue jsonValue(invokeResult.GetPayload());
            Aws::Map&lt;Aws::String, Aws::Utils::Json::JsonView&gt; values =
                    jsonValue.View().GetAllObjects();
            auto iter = values.find("result");
            if (iter != values.end() &amp;&amp; iter-&gt;second.IsIntegerType()) <span>{</span>
                <span>{</span>
                    std::cout &lt;&lt; INCREMENT_RESUlT_PREFIX
                              &lt;&lt; iter-&gt;second.AsInteger() &lt;&lt; std::endl;
                }
            }
            else <span>{</span>
                std::cout &lt;&lt; "There was an error in execution. Here is the log."
                          &lt;&lt; std::endl;
                Aws::Utils::ByteBuffer buffer = Aws::Utils::HashingUtils::Base64Decode(
                        invokeResult.GetLogResult());
                std::cout &lt;&lt; "With log " &lt;&lt; buffer.GetUnderlyingData() &lt;&lt; std::endl;
            }
        }
    }

    std::cout
            &lt;&lt; "The Lambda function will now be updated with new code. Press return to continue, ";
    Aws::String answer;
    std::getline(std::cin, answer);

    // 4.  Update the Lambda function code.
    <span>{</span>
        Aws::Lambda::Model::UpdateFunctionCodeRequest request;
        request.SetFunctionName(LAMBDA_NAME);
        std::ifstream ifstream(CALCULATOR_LAMBDA_CODE.c_str(),
                               std::ios_base::in | std::ios_base::binary);
        if (!ifstream.is_open()) <span>{</span>
            std::cerr &lt;&lt; "Error opening file " &lt;&lt; INCREMENT_LAMBDA_CODE &lt;&lt; "." &lt;&lt; std::endl;

#if USE_CPP_LAMBDA_FUNCTION
            std::cerr
                    &lt;&lt; "The cpp Lambda function must be built following the instructions in the cpp_lambda/README.md file. "
                    &lt;&lt; std::endl;
#endif
            deleteLambdaFunction(client);
            deleteIamRole(clientConfig);
            return false;
        }

        Aws::StringStream buffer;
        buffer &lt;&lt; ifstream.rdbuf();
        request.SetZipFile(
                Aws::Utils::ByteBuffer((unsigned char *) buffer.str().c_str(),
                                       buffer.str().length()));
        request.SetPublish(true);

        Aws::Lambda::Model::UpdateFunctionCodeOutcome outcome = client.UpdateFunctionCode(
                request);

        if (outcome.IsSuccess()) <span>{</span>
            std::cout &lt;&lt; "The lambda code was successfully updated." &lt;&lt; std::endl;
        }
        else <span>{</span>
            std::cerr &lt;&lt; "Error with Lambda::UpdateFunctionCode. "
                      &lt;&lt; outcome.GetError().GetMessage()
                      &lt;&lt; std::endl;
        }
    }

    std::cout
            &lt;&lt; "This function uses an environment variable to control the logging level."
            &lt;&lt; std::endl;
    std::cout
            &lt;&lt; "UpdateFunctionConfiguration will be used to set the LOG_LEVEL to DEBUG."
            &lt;&lt; std::endl;
    seconds = 0;

    // 5.  Update the Lambda function configuration.
    do <span>{</span>
        ++seconds;
        std::this_thread::sleep_for(std::chrono::seconds(1));
        Aws::Lambda::Model::UpdateFunctionConfigurationRequest request;
        request.SetFunctionName(LAMBDA_NAME);
        Aws::Lambda::Model::Environment environment;
        environment.AddVariables("LOG_LEVEL", "DEBUG");
        request.SetEnvironment(environment);

        Aws::Lambda::Model::UpdateFunctionConfigurationOutcome outcome = client.UpdateFunctionConfiguration(
                request);

        if (outcome.IsSuccess()) <span>{</span>
            std::cout &lt;&lt; "The lambda configuration was successfully updated."
                      &lt;&lt; std::endl;
            break;
        }

            // RESOURCE_IN_USE: function code update not completed.
        else if (outcome.GetError().GetErrorType() !=
                 Aws::Lambda::LambdaErrors::RESOURCE_IN_USE) <span>{</span>
            if ((seconds % 10) == 0) <span>{</span> // Log status every 10 seconds.
                std::cout &lt;&lt; "Lambda function update in progress . After " &lt;&lt; seconds
                          &lt;&lt; " seconds elapsed." &lt;&lt; std::endl;
            }
        }
        else <span>{</span>
            std::cerr &lt;&lt; "Error with Lambda::UpdateFunctionConfiguration. "
                      &lt;&lt; outcome.GetError().GetMessage()
                      &lt;&lt; std::endl;
        }

    } while (0 &lt; seconds);

    if (0 &gt; seconds) <span>{</span>
        std::cerr &lt;&lt; "Function failed to become active." &lt;&lt; std::endl;
    }
    else <span>{</span>
        std::cout &lt;&lt; "Updated function active after " &lt;&lt; seconds &lt;&lt; " seconds."
                  &lt;&lt; std::endl;
    }

    std::cout
            &lt;&lt; "\nThe new code applies an arithmetic operator to two variables, x an y."
            &lt;&lt; std::endl;
    std::vector&lt;Aws::String&gt; operators = <span>{</span>"plus", "minus", "times", "divided-by"};
    for (size_t i = 0; i &lt; operators.size(); ++i) <span>{</span>
        std::cout &lt;&lt; "   " &lt;&lt; i + 1 &lt;&lt; " " &lt;&lt; operators[i] &lt;&lt; std::endl;
    }

    // 6.  Invoke the updated Lambda function.
    do <span>{</span>
        int operatorIndex = askQuestionForIntRange("Select an operator index 1 - 4 ", 1,
                                                   4);
        int x = askQuestionForInt("Enter an integer for the x value ");
        int y = askQuestionForInt("Enter an integer for the y value ");

        Aws::Utils::Json::JsonValue calculateJsonPayload;
        calculateJsonPayload.WithString("action", operators[operatorIndex - 1]);
        calculateJsonPayload.WithInteger("x", x);
        calculateJsonPayload.WithInteger("y", y);
        Aws::Lambda::Model::InvokeResult calculatedResult;
        if (invokeLambdaFunction(calculateJsonPayload,
                                 Aws::Lambda::Model::LogType::Tail,
                                 calculatedResult, client)) <span>{</span>
            Aws::Utils::Json::JsonValue jsonValue(calculatedResult.GetPayload());
            Aws::Map&lt;Aws::String, Aws::Utils::Json::JsonView&gt; values =
                    jsonValue.View().GetAllObjects();
            auto iter = values.find("result");
            if (iter != values.end() &amp;&amp; iter-&gt;second.IsIntegerType()) <span>{</span>
                std::cout &lt;&lt; ARITHMETIC_RESUlT_PREFIX &lt;&lt; x &lt;&lt; " "
                          &lt;&lt; operators[operatorIndex - 1] &lt;&lt; " "
                          &lt;&lt; y &lt;&lt; " is " &lt;&lt; iter-&gt;second.AsInteger() &lt;&lt; std::endl;
            }
            else if (iter != values.end() &amp;&amp; iter-&gt;second.IsFloatingPointType()) <span>{</span>
                std::cout &lt;&lt; ARITHMETIC_RESUlT_PREFIX &lt;&lt; x &lt;&lt; " "
                          &lt;&lt; operators[operatorIndex - 1] &lt;&lt; " "
                          &lt;&lt; y &lt;&lt; " is " &lt;&lt; iter-&gt;second.AsDouble() &lt;&lt; std::endl;
            }
            else <span>{</span>
                std::cout &lt;&lt; "There was an error in execution. Here is the log."
                          &lt;&lt; std::endl;
                Aws::Utils::ByteBuffer buffer = Aws::Utils::HashingUtils::Base64Decode(
                        calculatedResult.GetLogResult());
                std::cout &lt;&lt; "With log " &lt;&lt; buffer.GetUnderlyingData() &lt;&lt; std::endl;
            }
        }

        answer = askQuestion("Would you like to try another operation? (y/n) ");
    } while (answer == "y");

    std::cout
            &lt;&lt; "A list of the lambda functions will be retrieved. Press return to continue, ";
    std::getline(std::cin, answer);

    // 7.  List the Lambda functions.

    std::vector&lt;Aws::String&gt; functions;
    Aws::String marker;

    do <span>{</span>
        Aws::Lambda::Model::ListFunctionsRequest request;
        if (!marker.empty()) <span>{</span>
            request.SetMarker(marker);
        }

        Aws::Lambda::Model::ListFunctionsOutcome outcome = client.ListFunctions(
                request);

        if (outcome.IsSuccess()) <span>{</span>
            const Aws::Lambda::Model::ListFunctionsResult &amp;result = outcome.GetResult();
            std::cout &lt;&lt; result.GetFunctions().size()
                      &lt;&lt; " lambda functions were retrieved." &lt;&lt; std::endl;

            for (const Aws::Lambda::Model::FunctionConfiguration &amp;functionConfiguration: result.GetFunctions()) <span>{</span>
                functions.push_back(functionConfiguration.GetFunctionName());
                std::cout &lt;&lt; functions.size() &lt;&lt; "  "
                          &lt;&lt; functionConfiguration.GetDescription() &lt;&lt; std::endl;
                std::cout &lt;&lt; "   "
                          &lt;&lt; Aws::Lambda::Model::RuntimeMapper::GetNameForRuntime(
                                  functionConfiguration.GetRuntime()) &lt;&lt; ": "
                          &lt;&lt; functionConfiguration.GetHandler()
                          &lt;&lt; std::endl;
            }
            marker = result.GetNextMarker();
        }
        else <span>{</span>
            std::cerr &lt;&lt; "Error with Lambda::ListFunctions. "
                      &lt;&lt; outcome.GetError().GetMessage()
                      &lt;&lt; std::endl;
        }
    } while (!marker.empty());

    // 8.  Get a Lambda function.
    if (!functions.empty()) <span>{</span>
        std::stringstream question;
        question &lt;&lt; "Choose a function to retrieve between 1 and " &lt;&lt; functions.size()
                 &lt;&lt; " ";
        int functionIndex = askQuestionForIntRange(question.str(), 1,
                                                   static_cast&lt;int&gt;(functions.size()));

        Aws::String functionName = functions[functionIndex - 1];

        Aws::Lambda::Model::GetFunctionRequest request;
        request.SetFunctionName(functionName);

        Aws::Lambda::Model::GetFunctionOutcome outcome = client.GetFunction(request);

        if (outcome.IsSuccess()) <span>{</span>
            std::cout &lt;&lt; "Function retrieve.\n" &lt;&lt;
                      outcome.GetResult().GetConfiguration().Jsonize().View().WriteReadable()
                      &lt;&lt; std::endl;
        }
        else <span>{</span>
            std::cerr &lt;&lt; "Error with Lambda::GetFunction. "
                      &lt;&lt; outcome.GetError().GetMessage()
                      &lt;&lt; std::endl;
        }
    }

    std::cout &lt;&lt; "The resources will be deleted. Press return to continue, ";
    std::getline(std::cin, answer);

    // 9.  Delete the Lambda function.
    bool result = deleteLambdaFunction(client);

    // 10. Delete the IAM role.
    return result &amp;&amp; deleteIamRole(clientConfig);
}

//! Routine which invokes a Lambda function and returns the result.
/*!
 \param jsonPayload: Payload for invoke function.
 \param logType: Log type setting for invoke function.
 \param invokeResult: InvokeResult object to receive the result.
 \param client: Lambda client.
 \return bool: Successful completion.
 */
bool
AwsDoc::Lambda::invokeLambdaFunction(const Aws::Utils::Json::JsonValue &amp;jsonPayload,
                                     Aws::Lambda::Model::LogType logType,
                                     Aws::Lambda::Model::InvokeResult &amp;invokeResult,
                                     const Aws::Lambda::LambdaClient &amp;client) <span>{</span>
    int seconds = 0;
    bool result = false;
    /*
     * In this example, the Invoke function can be called before recently created resources are
     * available.  The Invoke function is called repeatedly until the resources are
     * available.
     */
    do <span>{</span>
        Aws::Lambda::Model::InvokeRequest request;
        request.SetFunctionName(LAMBDA_NAME);
        request.SetLogType(logType);
        std::shared_ptr&lt;Aws::IOStream&gt; payload = Aws::MakeShared&lt;Aws::StringStream&gt;(
                "FunctionTest");
        *payload &lt;&lt; jsonPayload.View().WriteReadable();
        request.SetBody(payload);
        request.SetContentType("application/json");
        Aws::Lambda::Model::InvokeOutcome outcome = client.Invoke(request);

        if (outcome.IsSuccess()) <span>{</span>
            invokeResult = std::move(outcome.GetResult());
            result = true;
            break;
        }

            // ACCESS_DENIED: because the role is not available yet.
            // RESOURCE_CONFLICT: because the Lambda function is being created or updated.
        else if ((outcome.GetError().GetErrorType() ==
                  Aws::Lambda::LambdaErrors::ACCESS_DENIED) ||
                 (outcome.GetError().GetErrorType() ==
                  Aws::Lambda::LambdaErrors::RESOURCE_CONFLICT)) <span>{</span>
            if ((seconds % 5) == 0) <span>{</span> // Log status every 10 seconds.
                std::cout &lt;&lt; "Waiting for the invoke api to be available, status " &lt;&lt;
                          ((outcome.GetError().GetErrorType() ==
                            Aws::Lambda::LambdaErrors::ACCESS_DENIED ?
                            "ACCESS_DENIED" : "RESOURCE_CONFLICT")) &lt;&lt; ". " &lt;&lt; seconds
                          &lt;&lt; " seconds elapsed." &lt;&lt; std::endl;
            }
        }
        else <span>{</span>
            std::cerr &lt;&lt; "Error with Lambda::InvokeRequest. "
                      &lt;&lt; outcome.GetError().GetMessage()
                      &lt;&lt; std::endl;
            break;
        }
        ++seconds;
        std::this_thread::sleep_for(std::chrono::seconds(1));
    } while (seconds &lt; 60);

    return result;
}

</code></pre>
             
            <div class="itemizedlist">
                 
            <ul class="itemizedlist"><li class="listitem">
                    <p>For API details, see the following topics in <em>AWS SDK for C++ API Reference</em>.</p>
                    <div class="itemizedlist">
                         
                         
                         
                         
                         
                         
                         
                    <ul class="itemizedlist"><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForCpp/lambda-2015-03-31/CreateFunction">CreateFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForCpp/lambda-2015-03-31/DeleteFunction">DeleteFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForCpp/lambda-2015-03-31/GetFunction">GetFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForCpp/lambda-2015-03-31/Invoke">Invoke</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForCpp/lambda-2015-03-31/ListFunctions">ListFunctions</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForCpp/lambda-2015-03-31/UpdateFunctionCode">UpdateFunctionCode</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForCpp/lambda-2015-03-31/UpdateFunctionConfiguration">UpdateFunctionConfiguration</a></p></li></ul></div>
                </li></ul></div>
        </dd>
    </dl></div>
        </dd>
    <dt>Go</dt><dd tab-id="go">
            <div class="variablelist">
     
<dl>
        <dt><b><span class="term">SDK for Go V2</span></b></dt>
        <dd>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>
                    There's more on GitHub. Find the complete example and learn how to set up and run in the
                    <a href="https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/gov2/lambda#code-examples" rel="noopener noreferrer" target="_blank"><span>AWS Code Examples Repository</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>.
                </p></div></div>
             
                <p>Create an interactive scenario that shows you how to get started with Lambda functions.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="go ">
// GetStartedFunctionsScenario shows you how to use AWS Lambda to perform the following
// actions:
//
//  1. Create an AWS Identity and Access Management (IAM) role and Lambda function, then upload handler code.
//  2. Invoke the function with a single parameter and get results.
//  3. Update the function code and configure with an environment variable.
//  4. Invoke the function with new parameters and get results. Display the returned execution log.
//  5. List the functions for your account, then clean up resources.
type GetStartedFunctionsScenario struct <span>{</span>
	sdkConfig       aws.Config
	functionWrapper actions.FunctionWrapper
	questioner      demotools.IQuestioner
	helper          IScenarioHelper
	isTestRun       bool
}

// NewGetStartedFunctionsScenario constructs a GetStartedFunctionsScenario instance from a configuration.
// It uses the specified config to get a Lambda client and create wrappers for the actions
// used in the scenario.
func NewGetStartedFunctionsScenario(sdkConfig aws.Config, questioner demotools.IQuestioner,
	helper IScenarioHelper) GetStartedFunctionsScenario <span>{</span>
	lambdaClient := lambda.NewFromConfig(sdkConfig)
	return GetStartedFunctionsScenario<span>{</span>
		sdkConfig:       sdkConfig,
		functionWrapper: actions.FunctionWrapper<span>{</span>LambdaClient: lambdaClient},
		questioner:      questioner,
		helper:          helper,
	}
}

// Run runs the interactive scenario.
func (scenario GetStartedFunctionsScenario) Run() <span>{</span>
	defer func() <span>{</span>
		if r := recover(); r != nil <span>{</span>
			log.Printf("Something went wrong with the demo.\n")
		}
	}()

	log.Println(strings.Repeat("-", 88))
	log.Println("Welcome to the AWS Lambda get started with functions demo.")
	log.Println(strings.Repeat("-", 88))

	role := scenario.GetOrCreateRole()
	funcName := scenario.CreateFunction(role)
	scenario.InvokeIncrement(funcName)
	scenario.UpdateFunction(funcName)
	scenario.InvokeCalculator(funcName)
	scenario.ListFunctions()
	scenario.Cleanup(role, funcName)

	log.Println(strings.Repeat("-", 88))
	log.Println("Thanks for watching!")
	log.Println(strings.Repeat("-", 88))
}

// GetOrCreateRole checks whether the specified role exists and returns it if it does.
// Otherwise, a role is created that specifies Lambda as a trusted principal.
// The AWSLambdaBasicExecutionRole managed policy is attached to the role and the role
// is returned.
func (scenario GetStartedFunctionsScenario) GetOrCreateRole() *iamtypes.Role <span>{</span>
	var role *iamtypes.Role
	iamClient := iam.NewFromConfig(scenario.sdkConfig)
	log.Println("First, we need an IAM role that Lambda can assume.")
	roleName := scenario.questioner.Ask("Enter a name for the role:", demotools.NotEmpty<span>{</span>})
	getOutput, err := iamClient.GetRole(context.TODO(), &amp;iam.GetRoleInput<span>{</span>
		RoleName: aws.String(roleName)})
	if err != nil <span>{</span>
		var noSuch *iamtypes.NoSuchEntityException
		if errors.As(err, &amp;noSuch) <span>{</span>
			log.Printf("Role %v doesn't exist. Creating it....\n", roleName)
		} else <span>{</span>
			log.Panicf("Couldn't check whether role %v exists. Here's why: %v\n",
				roleName, err)
		}
	} else <span>{</span>
		role = getOutput.Role
		log.Printf("Found role %v.\n", *role.RoleName)
	}
	if role == nil <span>{</span>
		trustPolicy := PolicyDocument<span>{</span>
			Version: "2012-10-17",
			Statement: []PolicyStatement<span>{</span><span>{</span>
				Effect:    "Allow",
				Principal: map[string]string<span>{</span>"Service": "lambda.amazonaws.com"},
				Action:    []string<span>{</span>"sts:AssumeRole"},
			}},
		}
		policyArn := "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
		createOutput, err := iamClient.CreateRole(context.TODO(), &amp;iam.CreateRoleInput<span>{</span>
			AssumeRolePolicyDocument: aws.String(trustPolicy.String()),
			RoleName:                 aws.String(roleName),
		})
		if err != nil <span>{</span>
			log.Panicf("Couldn't create role %v. Here's why: %v\n", roleName, err)
		}
		role = createOutput.Role
		_, err = iamClient.AttachRolePolicy(context.TODO(), &amp;iam.AttachRolePolicyInput<span>{</span>
			PolicyArn: aws.String(policyArn),
			RoleName:  aws.String(roleName),
		})
		if err != nil <span>{</span>
			log.Panicf("Couldn't attach a policy to role %v. Here's why: %v\n", roleName, err)
		}
		log.Printf("Created role %v.\n", *role.RoleName)
		log.Println("Let's give AWS a few seconds to propagate resources...")
		scenario.helper.Pause(10)
	}
	log.Println(strings.Repeat("-", 88))
	return role
}

// CreateFunction creates a Lambda function and uploads a handler written in Python.
// The code for the Python handler is packaged as a []byte in .zip format.
func (scenario GetStartedFunctionsScenario) CreateFunction(role *iamtypes.Role) string <span>{</span>
	log.Println("Let's create a function that increments a number.\n" +
		"The function uses the 'lambda_handler_basic.py' script found in the \n" +
		"'handlers' directory of this project.")
	funcName := scenario.questioner.Ask("Enter a name for the Lambda function:", demotools.NotEmpty<span>{</span>})
	zipPackage := scenario.helper.CreateDeploymentPackage("lambda_handler_basic.py", fmt.Sprintf("%v.py", funcName))
	log.Printf("Creating function %v and waiting for it to be ready.", funcName)
	funcState := scenario.functionWrapper.CreateFunction(funcName, fmt.Sprintf("%v.lambda_handler", funcName),
		role.Arn, zipPackage)
	log.Printf("Your function is %v.", funcState)
	log.Println(strings.Repeat("-", 88))
	return funcName
}

// InvokeIncrement invokes a Lambda function that increments a number. The function
// parameters are contained in a Go struct that is used to serialize the parameters to
// a JSON payload that is passed to the function.
// The result payload is deserialized into a Go struct that contains an int value.
func (scenario GetStartedFunctionsScenario) InvokeIncrement(funcName string) <span>{</span>
	parameters := actions.IncrementParameters<span>{</span>Action: "increment"}
	log.Println("Let's invoke our function. This function increments a number.")
	parameters.Number = scenario.questioner.AskInt("Enter a number to increment:", demotools.NotEmpty<span>{</span>})
	log.Printf("Invoking %v with %v...\n", funcName, parameters.Number)
	invokeOutput := scenario.functionWrapper.Invoke(funcName, parameters, false)
	var payload actions.LambdaResultInt
	err := json.Unmarshal(invokeOutput.Payload, &amp;payload)
	if err != nil <span>{</span>
		log.Panicf("Couldn't unmarshal payload from invoking %v. Here's why: %v\n",
			funcName, err)
	}
	log.Printf("Invoking %v with %v returned %v.\n", funcName, parameters.Number, payload)
	log.Println(strings.Repeat("-", 88))
}

// UpdateFunction updates the code for a Lambda function by uploading a simple arithmetic
// calculator written in Python. The code for the Python handler is packaged as a
// []byte in .zip format.
// After the code is updated, the configuration is also updated with a new log
// level that instructs the handler to log additional information.
func (scenario GetStartedFunctionsScenario) UpdateFunction(funcName string) <span>{</span>
	log.Println("Let's update the function to an arithmetic calculator.\n" +
		"The function uses the 'lambda_handler_calculator.py' script found in the \n" +
		"'handlers' directory of this project.")
	scenario.questioner.Ask("Press Enter when you're ready.")
	log.Println("Creating deployment package...")
	zipPackage := scenario.helper.CreateDeploymentPackage("lambda_handler_calculator.py",
		fmt.Sprintf("%v.py", funcName))
	log.Println("...and updating the Lambda function and waiting for it to be ready.")
	funcState := scenario.functionWrapper.UpdateFunctionCode(funcName, zipPackage)
	log.Printf("Updated function %v. Its current state is %v.", funcName, funcState)
	log.Println("This function uses an environment variable to control logging level.")
	log.Println("Let's set it to DEBUG to get the most logging.")
	scenario.functionWrapper.UpdateFunctionConfiguration(funcName,
		map[string]string<span>{</span>"LOG_LEVEL": "DEBUG"})
	log.Println(strings.Repeat("-", 88))
}

// InvokeCalculator invokes the Lambda calculator function. The parameters are stored in a
// Go struct that is used to serialize the parameters to a JSON payload. That payload is then passed
// to the function.
// The result payload is deserialized to a Go struct that stores the result as either an
// int or float32, depending on the kind of operation that was specified.
func (scenario GetStartedFunctionsScenario) InvokeCalculator(funcName string) <span>{</span>
	wantInvoke := true
	choices := []string<span>{</span>"plus", "minus", "times", "divided-by"}
	for wantInvoke <span>{</span>
		choice := scenario.questioner.AskChoice("Select an arithmetic operation:\n", choices)
		x := scenario.questioner.AskInt("Enter a value for x:", demotools.NotEmpty<span>{</span>})
		y := scenario.questioner.AskInt("Enter a value for y:", demotools.NotEmpty<span>{</span>})
		log.Printf("Invoking %v %v %v...", x, choices[choice], y)
		calcParameters := actions.CalculatorParameters<span>{</span>
			Action: choices[choice],
			X:      x,
			Y:      y,
		}
		invokeOutput := scenario.functionWrapper.Invoke(funcName, calcParameters, true)
		var payload any
		if choice == 3 <span>{</span> // divide-by results in a float.
			payload = actions.LambdaResultFloat<span>{</span>}
		} else <span>{</span>
			payload = actions.LambdaResultInt<span>{</span>}
		}
		err := json.Unmarshal(invokeOutput.Payload, &amp;payload)
		if err != nil <span>{</span>
			log.Panicf("Couldn't unmarshal payload from invoking %v. Here's why: %v\n",
				funcName, err)
		}
		log.Printf("Invoking %v with %v %v %v returned %v.\n", funcName,
			calcParameters.X, calcParameters.Action, calcParameters.Y, payload)
		scenario.questioner.Ask("Press Enter to see the logs from the call.")
		logRes, err := base64.StdEncoding.DecodeString(*invokeOutput.LogResult)
		if err != nil <span>{</span>
			log.Panicf("Couldn't decode log result. Here's why: %v\n", err)
		}
		log.Println(string(logRes))
		wantInvoke = scenario.questioner.AskBool("Do you want to calculate again? (y/n)", "y")
	}
	log.Println(strings.Repeat("-", 88))
}

// ListFunctions lists up to the specified number of functions for your account.
func (scenario GetStartedFunctionsScenario) ListFunctions() <span>{</span>
	count := scenario.questioner.AskInt(
		"Let's list functions for your account. How many do you want to see?", demotools.NotEmpty<span>{</span>})
	functions := scenario.functionWrapper.ListFunctions(count)
	log.Printf("Found %v functions:", len(functions))
	for _, function := range functions <span>{</span>
		log.Printf("\t%v", *function.FunctionName)
	}
	log.Println(strings.Repeat("-", 88))
}

// Cleanup removes the IAM and Lambda resources created by the example.
func (scenario GetStartedFunctionsScenario) Cleanup(role *iamtypes.Role, funcName string) <span>{</span>
	if scenario.questioner.AskBool("Do you want to clean up resources created for this example? (y/n)",
		"y") <span>{</span>
		iamClient := iam.NewFromConfig(scenario.sdkConfig)
		policiesOutput, err := iamClient.ListAttachedRolePolicies(context.TODO(),
			&amp;iam.ListAttachedRolePoliciesInput<span>{</span>RoleName: role.RoleName})
		if err != nil <span>{</span>
			log.Panicf("Couldn't get policies attached to role %v. Here's why: %v\n",
				*role.RoleName, err)
		}
		for _, policy := range policiesOutput.AttachedPolicies <span>{</span>
			_, err = iamClient.DetachRolePolicy(context.TODO(), &amp;iam.DetachRolePolicyInput<span>{</span>
				PolicyArn: policy.PolicyArn, RoleName: role.RoleName,
			})
			if err != nil <span>{</span>
				log.Panicf("Couldn't detach policy %v from role %v. Here's why: %v\n",
					*policy.PolicyArn, *role.RoleName, err)
			}
		}
		_, err = iamClient.DeleteRole(context.TODO(), &amp;iam.DeleteRoleInput<span>{</span>RoleName: role.RoleName})
		if err != nil <span>{</span>
			log.Panicf("Couldn't delete role %v. Here's why: %v\n", *role.RoleName, err)
		}
		log.Printf("Deleted role %v.\n", *role.RoleName)

		scenario.functionWrapper.DeleteFunction(funcName)
		log.Printf("Deleted function %v.\n", funcName)
	} else <span>{</span>
		log.Println("Okay. Don't forget to delete the resources when you're done with them.")
	}
}


</code></pre>
             
             
                <p>Create a struct that wraps individual Lambda actions.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="go ">
// FunctionWrapper encapsulates function actions used in the examples.
// It contains an AWS Lambda service client that is used to perform user actions.
type FunctionWrapper struct <span>{</span>
	LambdaClient *lambda.Client
}


// GetFunction gets data about the Lambda function specified by functionName.
func (wrapper FunctionWrapper) GetFunction(functionName string) types.State <span>{</span>
	var state types.State
	funcOutput, err := wrapper.LambdaClient.GetFunction(context.TODO(), &amp;lambda.GetFunctionInput<span>{</span>
		FunctionName: aws.String(functionName),
	})
	if err != nil <span>{</span>
		log.Panicf("Couldn't get function %v. Here's why: %v\n", functionName, err)
	} else <span>{</span>
		state = funcOutput.Configuration.State
	}
	return state
}



// CreateFunction creates a new Lambda function from code contained in the zipPackage
// buffer. The specified handlerName must match the name of the file and function
// contained in the uploaded code. The role specified by iamRoleArn is assumed by
// Lambda and grants specific permissions.
// When the function already exists, types.StateActive is returned.
// When the function is created, a lambda.FunctionActiveV2Waiter is used to wait until the
// function is active.
func (wrapper FunctionWrapper) CreateFunction(functionName string, handlerName string,
	iamRoleArn *string, zipPackage *bytes.Buffer) types.State <span>{</span>
	var state types.State
	_, err := wrapper.LambdaClient.CreateFunction(context.TODO(), &amp;lambda.CreateFunctionInput<span>{</span>
		Code:         &amp;types.FunctionCode<span>{</span>ZipFile: zipPackage.Bytes()},
		FunctionName: aws.String(functionName),
		Role:         iamRoleArn,
		Handler:      aws.String(handlerName),
		Publish:      true,
		Runtime:      types.RuntimePython38,
	})
	if err != nil <span>{</span>
		var resConflict *types.ResourceConflictException
		if errors.As(err, &amp;resConflict) <span>{</span>
			log.Printf("Function %v already exists.\n", functionName)
			state = types.StateActive
		} else <span>{</span>
			log.Panicf("Couldn't create function %v. Here's why: %v\n", functionName, err)
		}
	} else <span>{</span>
		waiter := lambda.NewFunctionActiveV2Waiter(wrapper.LambdaClient)
		funcOutput, err := waiter.WaitForOutput(context.TODO(), &amp;lambda.GetFunctionInput<span>{</span>
			FunctionName: aws.String(functionName)}, 1*time.Minute)
		if err != nil <span>{</span>
			log.Panicf("Couldn't wait for function %v to be active. Here's why: %v\n", functionName, err)
		} else <span>{</span>
			state = funcOutput.Configuration.State
		}
	}
	return state
}



// UpdateFunctionCode updates the code for the Lambda function specified by functionName.
// The existing code for the Lambda function is entirely replaced by the code in the
// zipPackage buffer. After the update action is called, a lambda.FunctionUpdatedV2Waiter
// is used to wait until the update is successful.
func (wrapper FunctionWrapper) UpdateFunctionCode(functionName string, zipPackage *bytes.Buffer) types.State <span>{</span>
	var state types.State
	_, err := wrapper.LambdaClient.UpdateFunctionCode(context.TODO(), &amp;lambda.UpdateFunctionCodeInput<span>{</span>
		FunctionName: aws.String(functionName), ZipFile: zipPackage.Bytes(),
	})
	if err != nil <span>{</span>
		log.Panicf("Couldn't update code for function %v. Here's why: %v\n", functionName, err)
	} else <span>{</span>
		waiter := lambda.NewFunctionUpdatedV2Waiter(wrapper.LambdaClient)
		funcOutput, err := waiter.WaitForOutput(context.TODO(), &amp;lambda.GetFunctionInput<span>{</span>
			FunctionName: aws.String(functionName)}, 1*time.Minute)
		if err != nil <span>{</span>
			log.Panicf("Couldn't wait for function %v to be active. Here's why: %v\n", functionName, err)
		} else <span>{</span>
			state = funcOutput.Configuration.State
		}
	}
	return state
}



// UpdateFunctionConfiguration updates a map of environment variables configured for
// the Lambda function specified by functionName.
func (wrapper FunctionWrapper) UpdateFunctionConfiguration(functionName string, envVars map[string]string) <span>{</span>
	_, err := wrapper.LambdaClient.UpdateFunctionConfiguration(context.TODO(), &amp;lambda.UpdateFunctionConfigurationInput<span>{</span>
		FunctionName: aws.String(functionName),
		Environment:  &amp;types.Environment<span>{</span>Variables: envVars},
	})
	if err != nil <span>{</span>
		log.Panicf("Couldn't update configuration for %v. Here's why: %v", functionName, err)
	}
}



// ListFunctions lists up to maxItems functions for the account. This function uses a
// lambda.ListFunctionsPaginator to paginate the results.
func (wrapper FunctionWrapper) ListFunctions(maxItems int) []types.FunctionConfiguration <span>{</span>
	var functions []types.FunctionConfiguration
	paginator := lambda.NewListFunctionsPaginator(wrapper.LambdaClient, &amp;lambda.ListFunctionsInput<span>{</span>
		MaxItems: aws.Int32(int32(maxItems)),
	})
	for paginator.HasMorePages() &amp;&amp; len(functions) &lt; maxItems <span>{</span>
		pageOutput, err := paginator.NextPage(context.TODO())
		if err != nil <span>{</span>
			log.Panicf("Couldn't list functions for your account. Here's why: %v\n", err)
		}
		functions = append(functions, pageOutput.Functions...)
	}
	return functions
}



// DeleteFunction deletes the Lambda function specified by functionName.
func (wrapper FunctionWrapper) DeleteFunction(functionName string) <span>{</span>
	_, err := wrapper.LambdaClient.DeleteFunction(context.TODO(), &amp;lambda.DeleteFunctionInput<span>{</span>
		FunctionName: aws.String(functionName),
	})
	if err != nil <span>{</span>
		log.Panicf("Couldn't delete function %v. Here's why: %v\n", functionName, err)
	}
}



// Invoke invokes the Lambda function specified by functionName, passing the parameters
// as a JSON payload. When getLog is true, types.LogTypeTail is specified, which tells
// Lambda to include the last few log lines in the returned result.
func (wrapper FunctionWrapper) Invoke(functionName string, parameters any, getLog bool) *lambda.InvokeOutput <span>{</span>
	logType := types.LogTypeNone
	if getLog <span>{</span>
		logType = types.LogTypeTail
	}
	payload, err := json.Marshal(parameters)
	if err != nil <span>{</span>
		log.Panicf("Couldn't marshal parameters to JSON. Here's why %v\n", err)
	}
	invokeOutput, err := wrapper.LambdaClient.Invoke(context.TODO(), &amp;lambda.InvokeInput<span>{</span>
		FunctionName: aws.String(functionName),
		LogType:      logType,
		Payload:      payload,
	})
	if err != nil <span>{</span>
		log.Panicf("Couldn't invoke function %v. Here's why: %v\n", functionName, err)
	}
	return invokeOutput
}



// IncrementParameters is used to serialize parameters to the increment Lambda handler.
type IncrementParameters struct <span>{</span>
	Action string `json:"action"`
	Number int    `json:"number"`
}

// CalculatorParameters is used to serialize parameters to the calculator Lambda handler.
type CalculatorParameters struct <span>{</span>
	Action string `json:"action"`
	X      int    `json:"x"`
	Y      int    `json:"y"`
}

// LambdaResultInt is used to deserialize an int result from a Lambda handler.
type LambdaResultInt struct <span>{</span>
	Result int `json:"result"`
}

// LambdaResultFloat is used to deserialize a float32 result from a Lambda handler.
type LambdaResultFloat struct <span>{</span>
	Result float32 `json:"result"`
}


</code></pre>
             
             
                <p>Create a struct that implements functions to help run the scenario.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="go ">
// IScenarioHelper abstracts I/O and wait functions from a scenario so that they
// can be mocked for unit testing.
type IScenarioHelper interface <span>{</span>
	Pause(secs int)
	CreateDeploymentPackage(sourceFile string, destinationFile string) *bytes.Buffer
}

// ScenarioHelper lets the caller specify the path to Lambda handler functions.
type ScenarioHelper struct <span>{</span>
	HandlerPath string
}

// Pause waits for the specified number of seconds.
func (helper *ScenarioHelper) Pause(secs int) <span>{</span>
	time.Sleep(time.Duration(secs) * time.Second)
}

// CreateDeploymentPackage creates an AWS Lambda deployment package from a source file. The
// deployment package is stored in .zip format in a bytes.Buffer. The buffer can be
// used to pass a []byte to Lambda when creating the function.
// The specified destinationFile is the name to give the file when it's deployed to Lambda.
func (helper *ScenarioHelper) CreateDeploymentPackage(sourceFile string, destinationFile string) *bytes.Buffer <span>{</span>
	var err error
	buffer := &amp;bytes.Buffer<span>{</span>}
	writer := zip.NewWriter(buffer)
	zFile, err := writer.Create(destinationFile)
	if err != nil <span>{</span>
		log.Panicf("Couldn't create destination archive %v. Here's why: %v\n", destinationFile, err)
	}
	sourceBody, err := os.ReadFile(fmt.Sprintf("%v/%v", helper.HandlerPath, sourceFile))
	if err != nil <span>{</span>
		log.Panicf("Couldn't read handler source file %v. Here's why: %v\n",
			sourceFile, err)
	} else <span>{</span>
		_, err = zFile.Write(sourceBody)
		if err != nil <span>{</span>
			log.Panicf("Couldn't write handler %v to zip archive. Here's why: %v\n",
				sourceFile, err)
		}
	}
	err = writer.Close()
	if err != nil <span>{</span>
		log.Panicf("Couldn't close zip writer. Here's why: %v\n", err)
	}
	return buffer
}


</code></pre>
             
             
                <p>Define a Lambda handler that increments a number.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="go ">import logging

logger = logging.getLogger()
logger.setLevel(logging.INFO)


def lambda_handler(event, context):
    """
    Accepts an action and a single number, performs the specified action on the number,
    and returns the result. The only allowable action is 'increment'.

    :param event: The event dict that contains the parameters sent when the function
                  is invoked.
    :param context: The context in which the function is called.
    :return: The result of the action.
    """
    result = None
    action = event.get('action')
    if action == 'increment':
        result = event.get('number', 0) + 1
        logger.info('Calculated result of %s', result)
    else:
        logger.error("%s is not a valid action.", action)

    response = <span>{</span>'result': result}
    return response

</code></pre>
             
             
                <p>Define a second Lambda handler that performs arithmetic operations.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="go ">import logging
import os


logger = logging.getLogger()

# Define a list of Python lambda functions that are called by this AWS Lambda function.
ACTIONS = <span>{</span>
    'plus': lambda x, y: x + y,
    'minus': lambda x, y: x - y,
    'times': lambda x, y: x * y,
    'divided-by': lambda x, y: x / y}


def lambda_handler(event, context):
    """
    Accepts an action and two numbers, performs the specified action on the numbers,
    and returns the result.

    :param event: The event dict that contains the parameters sent when the function
                  is invoked.
    :param context: The context in which the function is called.
    :return: The result of the specified action.
    """
    # Set the log level based on a variable configured in the Lambda environment.
    logger.setLevel(os.environ.get('LOG_LEVEL', logging.INFO))
    logger.debug('Event: %s', event)

    action = event.get('action')
    func = ACTIONS.get(action)
    x = event.get('x')
    y = event.get('y')
    result = None
    try:
        if func is not None and x is not None and y is not None:
            result = func(x, y)
            logger.info("%s %s %s is %s", x, action, y, result)
        else:
            logger.error("I can't calculate %s %s %s.", x, action, y)
    except ZeroDivisionError:
        logger.warning("I can't divide %s by 0!", x)

    response = <span>{</span>'result': result}
    return response

</code></pre>
             
            <div class="itemizedlist">
                 
            <ul class="itemizedlist"><li class="listitem">
                    <p>For API details, see the following topics in <em>AWS SDK for Go API Reference</em>.</p>
                    <div class="itemizedlist">
                         
                         
                         
                         
                         
                         
                         
                    <ul class="itemizedlist"><li class="listitem"><p><a href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/lambda#Client.CreateFunction" rel="noopener noreferrer" target="_blank"><span>CreateFunction</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/lambda#Client.DeleteFunction" rel="noopener noreferrer" target="_blank"><span>DeleteFunction</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/lambda#Client.GetFunction" rel="noopener noreferrer" target="_blank"><span>GetFunction</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/lambda#Client.Invoke" rel="noopener noreferrer" target="_blank"><span>Invoke</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/lambda#Client.ListFunctions" rel="noopener noreferrer" target="_blank"><span>ListFunctions</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/lambda#Client.UpdateFunctionCode" rel="noopener noreferrer" target="_blank"><span>UpdateFunctionCode</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://pkg.go.dev/github.com/aws/aws-sdk-go-v2/service/lambda#Client.UpdateFunctionConfiguration" rel="noopener noreferrer" target="_blank"><span>UpdateFunctionConfiguration</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li></ul></div>
                </li></ul></div>
        </dd>
    </dl></div>
        </dd>
    <dt>Java</dt><dd tab-id="java">
            <div class="variablelist">
     
<dl>
        <dt><b><span class="term">SDK for Java 2.x</span></b></dt>
        <dd>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>
                    There's more on GitHub. Find the complete example and learn how to set up and run in the
                    <a href="https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/javav2/example_code/lambda#readme" rel="noopener noreferrer" target="_blank"><span>AWS Code Examples Repository</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>.
                </p></div></div>
             
                <p></p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="java ">/*
 *  Lambda function names appear as:
 *
 *  arn:aws:lambda:us-west-2:335556666777:function:HelloFunction
 *
 *  To find this value, look at the function in the AWS Management Console.
 *
 *  Before running this Java code example, set up your development environment, including your credentials.
 *
 *  For more information, see this documentation topic:
 *
 *  https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/get-started.html
 *
 *  This example performs the following tasks:
 *
 * 1. Creates an AWS Lambda function.
 * 2. Gets a specific AWS Lambda function.
 * 3. Lists all Lambda functions.
 * 4. Invokes a Lambda function.
 * 5. Updates the Lambda function code and invokes it again.
 * 6. Updates a Lambda function's configuration value.
 * 7. Deletes a Lambda function.
 */

public class LambdaScenario <span>{</span>
    public static final String DASHES = new String(new char[80]).replace("\0", "-");
    public static void main(String[] args) throws InterruptedException <span>{</span>

        final String usage = "\n" +
            "Usage:\n" +
            "    &lt;functionName&gt; &lt;filePath&gt; &lt;role&gt; &lt;handler&gt; &lt;bucketName&gt; &lt;key&gt; \n\n" +
            "Where:\n" +
            "    functionName - The name of the Lambda function. \n"+
            "    filePath - The path to the .zip or .jar where the code is located. \n"+
            "    role - The AWS Identity and Access Management (IAM) service role that has Lambda permissions. \n"+
            "    handler - The fully qualified method name (for example, example.Handler::handleRequest). \n"+
            "    bucketName - The Amazon Simple Storage Service (Amazon S3) bucket name that contains the .zip or .jar used to update the Lambda function's code. \n"+
            "    key - The Amazon S3 key name that represents the .zip or .jar (for example, LambdaHello-1.0-SNAPSHOT.jar)." ;

        if (args.length != 6) <span>{</span>
            System.out.println(usage);
            System.exit(1);
        }

        String functionName = args[0];
        String filePath = args[1];
        String role = args[2];
        String handler = args[3];
        String bucketName = args[4];
        String key = args[5];

        Region region = Region.US_WEST_2;
        LambdaClient awsLambda = LambdaClient.builder()
            .region(region)
            .credentialsProvider(ProfileCredentialsProvider.create())
            .build();

        System.out.println(DASHES);
        System.out.println("Welcome to the AWS Lambda example scenario.");
        System.out.println(DASHES);

        System.out.println(DASHES);
        System.out.println("1. Create an AWS Lambda function.");
        String funArn = createLambdaFunction(awsLambda, functionName, filePath, role, handler);
        System.out.println("The AWS Lambda ARN is "+funArn);
        System.out.println(DASHES);

        System.out.println(DASHES);
        System.out.println("2. Get the "+functionName + " AWS Lambda function.");
        getFunction(awsLambda, functionName);
        System.out.println(DASHES);

        System.out.println(DASHES);
        System.out.println("3. List all AWS Lambda functions.");
        listFunctions(awsLambda);
        System.out.println(DASHES);

        System.out.println(DASHES);
        System.out.println("4. Invoke the Lambda function.");
        System.out.println("*** Sleep for 1 min to get Lambda function ready.");
        Thread.sleep(60000);
        invokeFunction(awsLambda, functionName);
        System.out.println(DASHES);

        System.out.println(DASHES);
        System.out.println("5. Update the Lambda function code and invoke it again.");
        updateFunctionCode(awsLambda, functionName, bucketName, key);
        System.out.println("*** Sleep for 1 min to get Lambda function ready.");
        Thread.sleep(60000);
        invokeFunction(awsLambda, functionName);
        System.out.println(DASHES);

        System.out.println(DASHES);
        System.out.println("6. Update a Lambda function's configuration value.");
        updateFunctionConfiguration(awsLambda, functionName, handler);
        System.out.println(DASHES);

        System.out.println(DASHES);
        System.out.println("7. Delete the AWS Lambda function.");
        LambdaScenario.deleteLambdaFunction(awsLambda, functionName);
        System.out.println(DASHES);

        System.out.println(DASHES);
        System.out.println("The AWS Lambda scenario completed successfully");
        System.out.println(DASHES);
        awsLambda.close();
    }

    public static String createLambdaFunction(LambdaClient awsLambda,
                                            String functionName,
                                            String filePath,
                                            String role,
                                            String handler) <span>{</span>

        try <span>{</span>
            LambdaWaiter waiter = awsLambda.waiter();
            InputStream is = new FileInputStream(filePath);
            SdkBytes fileToUpload = SdkBytes.fromInputStream(is);

            FunctionCode code = FunctionCode.builder()
                .zipFile(fileToUpload)
                .build();

            CreateFunctionRequest functionRequest = CreateFunctionRequest.builder()
                .functionName(functionName)
                .description("Created by the Lambda Java API")
                .code(code)
                .handler(handler)
                .runtime(Runtime.JAVA8)
                .role(role)
                .build();

            // Create a Lambda function using a waiter
            CreateFunctionResponse functionResponse = awsLambda.createFunction(functionRequest);
            GetFunctionRequest getFunctionRequest = GetFunctionRequest.builder()
                .functionName(functionName)
                .build();
            WaiterResponse&lt;GetFunctionResponse&gt; waiterResponse = waiter.waitUntilFunctionExists(getFunctionRequest);
            waiterResponse.matched().response().ifPresent(System.out::println);
            return functionResponse.functionArn();

        } catch(LambdaException | FileNotFoundException e) <span>{</span>
            System.err.println(e.getMessage());
            System.exit(1);
        }
        return "";
    }

    public static void getFunction(LambdaClient awsLambda, String functionName) <span>{</span>
        try <span>{</span>
            GetFunctionRequest functionRequest = GetFunctionRequest.builder()
                .functionName(functionName)
                .build();

            GetFunctionResponse response = awsLambda.getFunction(functionRequest);
            System.out.println("The runtime of this Lambda function is " +response.configuration().runtime());

        } catch(LambdaException e) <span>{</span>
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }

    public static void listFunctions(LambdaClient awsLambda) <span>{</span>
        try <span>{</span>
            ListFunctionsResponse functionResult = awsLambda.listFunctions();
            List&lt;FunctionConfiguration&gt; list = functionResult.functions();
            for (FunctionConfiguration config: list) <span>{</span>
                System.out.println("The function name is "+config.functionName());
            }

        } catch(LambdaException e) <span>{</span>
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }

    public static void invokeFunction(LambdaClient awsLambda, String functionName) <span>{</span>

        InvokeResponse res;
        try <span>{</span>
            // Need a SdkBytes instance for the payload.
            JSONObject jsonObj = new JSONObject();
            jsonObj.put("inputValue", "2000");
            String json = jsonObj.toString();
            SdkBytes payload = SdkBytes.fromUtf8String(json) ;

            InvokeRequest request = InvokeRequest.builder()
                .functionName(functionName)
                .payload(payload)
                .build();

            res = awsLambda.invoke(request);
            String value = res.payload().asUtf8String() ;
            System.out.println(value);

        } catch(LambdaException e) <span>{</span>
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }

    public static void updateFunctionCode(LambdaClient awsLambda, String functionName, String bucketName, String key) <span>{</span>
        try <span>{</span>
            LambdaWaiter waiter = awsLambda.waiter();
            UpdateFunctionCodeRequest functionCodeRequest = UpdateFunctionCodeRequest.builder()
                .functionName(functionName)
                .publish(true)
                .s3Bucket(bucketName)
                .s3Key(key)
                .build();

            UpdateFunctionCodeResponse response = awsLambda.updateFunctionCode(functionCodeRequest) ;
            GetFunctionConfigurationRequest getFunctionConfigRequest = GetFunctionConfigurationRequest.builder()
                .functionName(functionName)
                .build();

            WaiterResponse&lt;GetFunctionConfigurationResponse&gt; waiterResponse = waiter.waitUntilFunctionUpdated(getFunctionConfigRequest);
            waiterResponse.matched().response().ifPresent(System.out::println);
            System.out.println("The last modified value is " +response.lastModified());

        } catch(LambdaException e) <span>{</span>
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }

    public static void updateFunctionConfiguration(LambdaClient awsLambda, String functionName, String handler )<span>{</span>
        try <span>{</span>
            UpdateFunctionConfigurationRequest configurationRequest = UpdateFunctionConfigurationRequest.builder()
                .functionName(functionName)
                .handler(handler)
                .runtime(Runtime.JAVA11 )
                .build();

            awsLambda.updateFunctionConfiguration(configurationRequest);

        } catch(LambdaException e) <span>{</span>
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }

    public static void deleteLambdaFunction(LambdaClient awsLambda, String functionName ) <span>{</span>
        try <span>{</span>
            DeleteFunctionRequest request = DeleteFunctionRequest.builder()
                .functionName(functionName)
                .build();

            awsLambda.deleteFunction(request);
            System.out.println("The "+functionName +" function was deleted");

        } catch(LambdaException e) <span>{</span>
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }
}

</code></pre>
             
            <div class="itemizedlist">
                 
            <ul class="itemizedlist"><li class="listitem">
                    <p>For API details, see the following topics in <em>AWS SDK for Java 2.x API Reference</em>.</p>
                    <div class="itemizedlist">
                         
                         
                         
                         
                         
                         
                         
                    <ul class="itemizedlist"><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForJavaV2/lambda-2015-03-31/CreateFunction">CreateFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForJavaV2/lambda-2015-03-31/DeleteFunction">DeleteFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForJavaV2/lambda-2015-03-31/GetFunction">GetFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForJavaV2/lambda-2015-03-31/Invoke">Invoke</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForJavaV2/lambda-2015-03-31/ListFunctions">ListFunctions</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForJavaV2/lambda-2015-03-31/UpdateFunctionCode">UpdateFunctionCode</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForJavaV2/lambda-2015-03-31/UpdateFunctionConfiguration">UpdateFunctionConfiguration</a></p></li></ul></div>
                </li></ul></div>
        </dd>
    </dl></div>
        </dd>
    <dt>JavaScript</dt><dd tab-id="javascript">
            <div class="variablelist">
     
<dl>
        <dt><b><span class="term">SDK for JavaScript (v3)</span></b></dt>
        <dd>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>
                    There's more on GitHub. Find the complete example and learn how to set up and run in the
                    <a href="https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/javascriptv3/example_code/lambda/scenarios/basic#code-examples" rel="noopener noreferrer" target="_blank"><span>AWS Code Examples Repository</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>.
                </p></div></div>
             
                <p>Create an AWS Identity and Access Management (IAM) role that grants Lambda permission to write to logs.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="javascript ">    log(`Creating role ($<span>{</span>NAME_ROLE_LAMBDA})...`);
    const response = await createRole(NAME_ROLE_LAMBDA);

import <span>{</span> AttachRolePolicyCommand, IAMClient } from "@aws-sdk/client-iam";

const client = new IAMClient(<span>{</span>});

/**
 *
 * @param <span>{</span>string} policyArn
 * @param <span>{</span>string} roleName
 */
export const attachRolePolicy = (policyArn, roleName) =&gt; <span>{</span>
  const command = new AttachRolePolicyCommand(<span>{</span>
    PolicyArn: policyArn,
    RoleName: roleName,
  });

  return client.send(command);
};

</code></pre>
             
             
                <p>Create a Lambda function and upload handler code.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="javascript ">const createFunction = async (funcName, roleArn) =&gt; <span>{</span>
  const client = new LambdaClient(<span>{</span>});
  const code = await readFile(`$<span>{</span>dirname}../functions/$<span>{</span>funcName}.zip`);

  const command = new CreateFunctionCommand(<span>{</span>
    Code: <span>{</span> ZipFile: code },
    FunctionName: funcName,
    Role: roleArn,
    Architectures: [Architecture.arm64],
    Handler: "index.handler", // Required when sending a .zip file
    PackageType: PackageType.Zip, // Required when sending a .zip file
    Runtime: Runtime.nodejs16x, // Required when sending a .zip file
  });

  return client.send(command);
};

</code></pre>
             
             
                <p>Invoke the function with a single parameter and get results.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="javascript ">const invoke = async (funcName, payload) =&gt; <span>{</span>
  const client = createClientForDefaultRegion(LambdaClient);
  const command = new InvokeCommand(<span>{</span>
    FunctionName: funcName,
    Payload: JSON.stringify(payload),
    LogType: LogType.Tail,
  });

  const <span>{</span> Payload, LogResult } = await client.send(command);
  const result = Buffer.from(Payload).toString();
  const logs = Buffer.from(LogResult, "base64").toString();
  return <span>{</span> logs, result };
};

</code></pre>
             
             
                <p>Update the function code and configure its Lambda environment with an environment variable.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="javascript ">const updateFunctionCode = async (funcName, newFunc) =&gt; <span>{</span>
  const client = createClientForDefaultRegion(LambdaClient);
  const code = await readFile(`$<span>{</span>dirname}../functions/$<span>{</span>newFunc}.zip`);
  const command = new UpdateFunctionCodeCommand(<span>{</span>
    ZipFile: code,
    FunctionName: funcName,
    Architectures: [Architecture.arm64],
    Handler: "index.handler", // Required when sending a .zip file
    PackageType: PackageType.Zip, // Required when sending a .zip file
    Runtime: Runtime.nodejs16x, // Required when sending a .zip file
  });

  return client.send(command);
};

const updateFunctionConfiguration = (funcName) =&gt; <span>{</span>
  const client = new LambdaClient(<span>{</span>});
  const config = readFileSync(`$<span>{</span>dirname}../functions/config.json`).toString();
  const command = new UpdateFunctionConfigurationCommand(<span>{</span>
    ...JSON.parse(config),
    FunctionName: funcName,
  });
  return client.send(command);
};

</code></pre>
             
             
                <p>List the functions for your account.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="javascript ">const listFunctions = () =&gt; <span>{</span>
  const client = new LambdaClient(<span>{</span>});
  const command = new ListFunctionsCommand(<span>{</span>});

  return client.send(command);
};

</code></pre>
             
             
                <p>Delete the IAM role and the Lambda function.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="javascript ">import <span>{</span> DeleteRoleCommand, IAMClient } from "@aws-sdk/client-iam";

const client = new IAMClient(<span>{</span>});

/**
 *
 * @param <span>{</span>string} roleName
 */
export const deleteRole = (roleName) =&gt; <span>{</span>
  const command = new DeleteRoleCommand(<span>{</span> RoleName: roleName });
  return client.send(command);
};

/**
 * @param <span>{</span>string} funcName
 */
const deleteFunction = (funcName) =&gt; <span>{</span>
  const client = new LambdaClient(<span>{</span>});
  const command = new DeleteFunctionCommand(<span>{</span> FunctionName: funcName });
  return client.send(command);
};

</code></pre>
             
            <div class="itemizedlist">
                 
            <ul class="itemizedlist"><li class="listitem">
                    <p>For API details, see the following topics in <em>AWS SDK for JavaScript API Reference</em>.</p>
                    <div class="itemizedlist">
                         
                         
                         
                         
                         
                         
                         
                    <ul class="itemizedlist"><li class="listitem"><p><a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/lambda/command/CreateFunctionCommand">CreateFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/lambda/command/DeleteFunctionCommand">DeleteFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/lambda/command/GetFunctionCommand">GetFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/lambda/command/InvokeCommand">Invoke</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/lambda/command/ListFunctionsCommand">ListFunctions</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/lambda/command/UpdateFunctionCodeCommand">UpdateFunctionCode</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/lambda/command/UpdateFunctionConfigurationCommand">UpdateFunctionConfiguration</a></p></li></ul></div>
                </li></ul></div>
        </dd>
    </dl></div>
        </dd>
    <dt>Kotlin</dt><dd tab-id="kotlin">
            <div class="variablelist">
     
<dl>
        <dt><b><span class="term">SDK for Kotlin</span></b></dt>
        <dd>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>This is prerelease documentation for a feature in preview release. It is subject to change.</p></div></div>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>
                    There's more on GitHub. Find the complete example and learn how to set up and run in the
                    <a href="https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/kotlin/services/lambda#code-examples" rel="noopener noreferrer" target="_blank"><span>AWS Code Examples Repository</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>.
                </p></div></div>
             
                <p></p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="kotlin ">suspend fun main(args: Array&lt;String&gt;) <span>{</span>

    val usage = """
        Usage:
            &lt;functionName&gt; &lt;role&gt; &lt;handler&gt; &lt;bucketName&gt; &lt;updatedBucketName&gt; &lt;key&gt; 

        Where:
            functionName - The name of the AWS Lambda function. 
            role - The AWS Identity and Access Management (IAM) service role that has AWS Lambda permissions. 
            handler - The fully qualified method name (for example, example.Handler::handleRequest). 
            bucketName - The Amazon Simple Storage Service (Amazon S3) bucket name that contains the ZIP or JAR used for the Lambda function's code.
            updatedBucketName - The Amazon S3 bucket name that contains the .zip or .jar used to update the Lambda function's code. 
            key - The Amazon S3 key name that represents the .zip or .jar file (for example, LambdaHello-1.0-SNAPSHOT.jar).
            """

    if (args.size != 6) <span>{</span>
        println(usage)
        exitProcess(1)
    }

    val functionName = args[0]
    val role = args[1]
    val handler = args[2]
    val bucketName = args[3]
    val updatedBucketName = args[4]
    val key = args[5]

    println("Creating a Lambda function named $functionName.")
    val funArn = createScFunction(functionName, bucketName, key, handler, role)
    println("The AWS Lambda ARN is $funArn")

    // Get a specific Lambda function.
    println("Getting the $functionName AWS Lambda function.")
    getFunction(functionName)

    // List the Lambda functions.
    println("Listing all AWS Lambda functions.")
    listFunctionsSc()

    // Invoke the Lambda function.
    println("*** Invoke the Lambda function.")
    invokeFunctionSc(functionName)

    // Update the AWS Lambda function code.
    println("*** Update the Lambda function code.")
    updateFunctionCode(functionName, updatedBucketName, key)

    // println("*** Invoke the function again after updating the code.")
    invokeFunctionSc(functionName)

    // Update the AWS Lambda function configuration.
    println("Update the run time of the function.")
    UpdateFunctionConfiguration(functionName, handler)

    // Delete the AWS Lambda function.
    println("Delete the AWS Lambda function.")
    delFunction(functionName)
}

suspend fun createScFunction(
    myFunctionName: String,
    s3BucketName: String,
    myS3Key: String,
    myHandler: String,
    myRole: String
): String <span>{</span>

    val functionCode = FunctionCode <span>{</span>
        s3Bucket = s3BucketName
        s3Key = myS3Key
    }

    val request = CreateFunctionRequest <span>{</span>
        functionName = myFunctionName
        code = functionCode
        description = "Created by the Lambda Kotlin API"
        handler = myHandler
        role = myRole
        runtime = Runtime.Java8
    }

    // Create a Lambda function using a waiter
    LambdaClient <span>{</span> region = "us-west-2" }.use <span>{</span> awsLambda -&gt;
        val functionResponse = awsLambda.createFunction(request)
        awsLambda.waitUntilFunctionActive <span>{</span>
            functionName = myFunctionName
        }
        return functionResponse.functionArn.toString()
    }
}

suspend fun getFunction(functionNameVal: String) <span>{</span>

    val functionRequest = GetFunctionRequest <span>{</span>
        functionName = functionNameVal
    }

    LambdaClient <span>{</span> region = "us-west-2" }.use <span>{</span> awsLambda -&gt;
        val response = awsLambda.getFunction(functionRequest)
        println("The runtime of this Lambda function is $<span>{</span>response.configuration?.runtime}")
    }
}

suspend fun listFunctionsSc() <span>{</span>

    val request = ListFunctionsRequest <span>{</span>
        maxItems = 10
    }

    LambdaClient <span>{</span> region = "us-west-2" }.use <span>{</span> awsLambda -&gt;
        val response = awsLambda.listFunctions(request)
        response.functions?.forEach <span>{</span> function -&gt;
            println("The function name is $<span>{</span>function.functionName}")
        }
    }
}

suspend fun invokeFunctionSc(functionNameVal: String) <span>{</span>

    val json = """<span>{</span>"inputValue":"1000"}"""
    val byteArray = json.trimIndent().encodeToByteArray()
    val request = InvokeRequest <span>{</span>
        functionName = functionNameVal
        payload = byteArray
        logType = LogType.Tail
    }

    LambdaClient <span>{</span> region = "us-west-2" }.use <span>{</span> awsLambda -&gt;
        val res = awsLambda.invoke(request)
        println("The function payload is $<span>{</span>res.payload?.toString(Charsets.UTF_8)}")
    }
}

suspend fun updateFunctionCode(functionNameVal: String?, bucketName: String?, key: String?) <span>{</span>

    val functionCodeRequest = UpdateFunctionCodeRequest <span>{</span>
        functionName = functionNameVal
        publish = true
        s3Bucket = bucketName
        s3Key = key
    }

    LambdaClient <span>{</span> region = "us-west-2" }.use <span>{</span> awsLambda -&gt;
        val response = awsLambda.updateFunctionCode(functionCodeRequest)
        awsLambda.waitUntilFunctionUpdated <span>{</span>
            functionName = functionNameVal
        }
        println("The last modified value is " + response.lastModified)
    }
}

suspend fun UpdateFunctionConfiguration(functionNameVal: String?, handlerVal: String?) <span>{</span>

    val configurationRequest = UpdateFunctionConfigurationRequest <span>{</span>
        functionName = functionNameVal
        handler = handlerVal
        runtime = Runtime.Java11
    }

    LambdaClient <span>{</span> region = "us-west-2" }.use <span>{</span> awsLambda -&gt;
        awsLambda.updateFunctionConfiguration(configurationRequest)
    }
}

suspend fun delFunction(myFunctionName: String) <span>{</span>

    val request = DeleteFunctionRequest <span>{</span>
        functionName = myFunctionName
    }

    LambdaClient <span>{</span> region = "us-west-2" }.use <span>{</span> awsLambda -&gt;
        awsLambda.deleteFunction(request)
        println("$myFunctionName was deleted")
    }
}

</code></pre>
             
            <div class="itemizedlist">
                 
            <ul class="itemizedlist"><li class="listitem">
                    <p>For API details, see the following topics in <em>AWS SDK for Kotlin API reference</em>.</p>
                    <div class="itemizedlist">
                         
                         
                         
                         
                         
                         
                         
                    <ul class="itemizedlist"><li class="listitem"><p><a href="https://github.com/awslabs/aws-sdk-kotlin#generating-api-documentation" rel="noopener noreferrer" target="_blank"><span>CreateFunction</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://github.com/awslabs/aws-sdk-kotlin#generating-api-documentation" rel="noopener noreferrer" target="_blank"><span>DeleteFunction</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://github.com/awslabs/aws-sdk-kotlin#generating-api-documentation" rel="noopener noreferrer" target="_blank"><span>GetFunction</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://github.com/awslabs/aws-sdk-kotlin#generating-api-documentation" rel="noopener noreferrer" target="_blank"><span>Invoke</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://github.com/awslabs/aws-sdk-kotlin#generating-api-documentation" rel="noopener noreferrer" target="_blank"><span>ListFunctions</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://github.com/awslabs/aws-sdk-kotlin#generating-api-documentation" rel="noopener noreferrer" target="_blank"><span>UpdateFunctionCode</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://github.com/awslabs/aws-sdk-kotlin#generating-api-documentation" rel="noopener noreferrer" target="_blank"><span>UpdateFunctionConfiguration</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li></ul></div>
                </li></ul></div>
        </dd>
    </dl></div>
        </dd>
    <dt>PHP</dt><dd tab-id="php">
            <div class="variablelist">
     
<dl>
        <dt><b><span class="term">SDK for PHP</span></b></dt>
        <dd>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>
                    There's more on GitHub. Find the complete example and learn how to set up and run in the
                    <a href="https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/php/example_code/lambda#code-examples" rel="noopener noreferrer" target="_blank"><span>AWS Code Examples Repository</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>.
                </p></div></div>
             
                <p></p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="php ">namespace Lambda;

use Aws\S3\S3Client;
use GuzzleHttp\Psr7\Stream;
use Iam\IAMService;

class GettingStartedWithLambda
<span>{</span>
    public function run()
    <span>{</span>
        echo("\n");
        echo("--------------------------------------\n");
        print("Welcome to the AWS Lambda getting started demo using PHP!\n");
        echo("--------------------------------------\n");

        $clientArgs = [
            'region' =&gt; 'us-west-2',
            'version' =&gt; 'latest',
            'profile' =&gt; 'default',
        ];
        $uniqid = uniqid();

        $iamService = new IAMService();
        $s3client = new S3Client($clientArgs);
        $lambdaService = new LambdaService();

        echo "First, let's create a role to run our Lambda code.\n";
        $roleName = "test-lambda-role-$uniqid";
        $rolePolicyDocument = "<span>{</span>
            \"Version\": \"2012-10-17\",
            \"Statement\": [
                <span>{</span>
                    \"Effect\": \"Allow\",
                    \"Principal\": <span>{</span>
                        \"Service\": \"lambda.amazonaws.com\"
                    },
                    \"Action\": \"sts:AssumeRole\"
                }
            ]
        }";
        $role = $iamService-&gt;createRole($roleName, $rolePolicyDocument);
        echo "Created role <span>{</span>$role['RoleName']}.\n";

        $iamService-&gt;attachRolePolicy(
            $role['RoleName'],
            "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
        );
        echo "Attached the AWSLambdaBasicExecutionRole to <span>{</span>$role['RoleName']}.\n";

        echo "\nNow let's create an S3 bucket and upload our Lambda code there.\n";
        $bucketName = "test-example-bucket-$uniqid";
        $s3client-&gt;createBucket([
            'Bucket' =&gt; $bucketName,
        ]);
        echo "Created bucket $bucketName.\n";

        $functionName = "doc_example_lambda_$uniqid";
        $codeBasic = __DIR__ . "/lambda_handler_basic.zip";
        $handler = "lambda_handler_basic";
        $file = file_get_contents($codeBasic);
        $s3client-&gt;putObject([
            'Bucket' =&gt; $bucketName,
            'Key' =&gt; $functionName,
            'Body' =&gt; $file,
        ]);
        echo "Uploaded the Lambda code.\n";

        $createLambdaFunction = $lambdaService-&gt;createFunction($functionName, $role, $bucketName, $handler);
        // Wait until the function has finished being created.
        do <span>{</span>
            $getLambdaFunction = $lambdaService-&gt;getFunction($createLambdaFunction['FunctionName']);
        } while ($getLambdaFunction['Configuration']['State'] == "Pending");
        echo "Created Lambda function <span>{</span>$getLambdaFunction['Configuration']['FunctionName']}.\n";

        sleep(1);

        echo "\nOk, let's invoke that Lambda code.\n";
        $basicParams = [
            'action' =&gt; 'increment',
            'number' =&gt; 3,
        ];
        /** @var Stream $invokeFunction */
        $invokeFunction = $lambdaService-&gt;invoke($functionName, $basicParams)['Payload'];
        $result = json_decode($invokeFunction-&gt;getContents())-&gt;result;
        echo "After invoking the Lambda code with the input of <span>{</span>$basicParams['number']} we received $result.\n";

        echo "\nSince that's working, let's update the Lambda code.\n";
        $codeCalculator = "lambda_handler_calculator.zip";
        $handlerCalculator = "lambda_handler_calculator";
        echo "First, put the new code into the S3 bucket.\n";
        $file = file_get_contents($codeCalculator);
        $s3client-&gt;putObject([
            'Bucket' =&gt; $bucketName,
            'Key' =&gt; $functionName,
            'Body' =&gt; $file,
        ]);
        echo "New code uploaded.\n";

        $lambdaService-&gt;updateFunctionCode($functionName, $bucketName, $functionName);
        // Wait for the Lambda code to finish updating.
        do <span>{</span>
            $getLambdaFunction = $lambdaService-&gt;getFunction($createLambdaFunction['FunctionName']);
        } while ($getLambdaFunction['Configuration']['LastUpdateStatus'] !== "Successful");
        echo "New Lambda code uploaded.\n";

        $environment = [
            'Variable' =&gt; ['Variables' =&gt; ['LOG_LEVEL' =&gt; 'DEBUG']],
        ];
        $lambdaService-&gt;updateFunctionConfiguration($functionName, $handlerCalculator, $environment);
        do <span>{</span>
            $getLambdaFunction = $lambdaService-&gt;getFunction($createLambdaFunction['FunctionName']);
        } while ($getLambdaFunction['Configuration']['LastUpdateStatus'] !== "Successful");
        echo "Lambda code updated with new handler and a LOG_LEVEL of DEBUG for more information.\n";

        echo "Invoke the new code with some new data.\n";
        $calculatorParams = [
            'action' =&gt; 'plus',
            'x' =&gt; 5,
            'y' =&gt; 4,
        ];
        $invokeFunction = $lambdaService-&gt;invoke($functionName, $calculatorParams, "Tail");
        $result = json_decode($invokeFunction['Payload']-&gt;getContents())-&gt;result;
        echo "Indeed, <span>{</span>$calculatorParams['x']} + <span>{</span>$calculatorParams['y']} does equal $result.\n";
        echo "Here's the extra debug info: ";
        echo base64_decode($invokeFunction['LogResult']) . "\n";

        echo "\nBut what happens if you try to divide by zero?\n";
        $divZeroParams = [
            'action' =&gt; 'divide',
            'x' =&gt; 5,
            'y' =&gt; 0,
        ];
        $invokeFunction = $lambdaService-&gt;invoke($functionName, $divZeroParams, "Tail");
        $result = json_decode($invokeFunction['Payload']-&gt;getContents())-&gt;result;
        echo "You get a |$result| result.\n";
        echo "And an error message: ";
        echo base64_decode($invokeFunction['LogResult']) . "\n";

        echo "\nHere's all the Lambda functions you have in this Region:\n";
        $listLambdaFunctions = $lambdaService-&gt;listFunctions(5);
        $allLambdaFunctions = $listLambdaFunctions['Functions'];
        $next = $listLambdaFunctions-&gt;get('NextMarker');
        while ($next != false) <span>{</span>
            $listLambdaFunctions = $lambdaService-&gt;listFunctions(5, $next);
            $next = $listLambdaFunctions-&gt;get('NextMarker');
            $allLambdaFunctions = array_merge($allLambdaFunctions, $listLambdaFunctions['Functions']);
        }
        foreach ($allLambdaFunctions as $function) <span>{</span>
            echo "<span>{</span>$function['FunctionName']}\n";
        }

        echo "\n\nAnd don't forget to clean up your data!\n";

        $lambdaService-&gt;deleteFunction($functionName);
        echo "Deleted Lambda function.\n";
        $iamService-&gt;deleteRole($role['RoleName']);
        echo "Deleted Role.\n";
        $deleteObjects = $s3client-&gt;listObjectsV2([
            'Bucket' =&gt; $bucketName,
        ]);
        $deleteObjects = $s3client-&gt;deleteObjects([
            'Bucket' =&gt; $bucketName,
            'Delete' =&gt; [
                'Objects' =&gt; $deleteObjects['Contents'],
            ]
        ]);
        echo "Deleted all objects from the S3 bucket.\n";
        $s3client-&gt;deleteBucket(['Bucket' =&gt; $bucketName]);
        echo "Deleted the bucket.\n";
    }
}

</code></pre>
             
            <div class="itemizedlist">
                 
            <ul class="itemizedlist"><li class="listitem">
                    <p>For API details, see the following topics in <em>AWS SDK for PHP API Reference</em>.</p>
                    <div class="itemizedlist">
                         
                         
                         
                         
                         
                         
                         
                    <ul class="itemizedlist"><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForPHPV3/lambda-2015-03-31/CreateFunction">CreateFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForPHPV3/lambda-2015-03-31/DeleteFunction">DeleteFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForPHPV3/lambda-2015-03-31/GetFunction">GetFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForPHPV3/lambda-2015-03-31/Invoke">Invoke</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForPHPV3/lambda-2015-03-31/ListFunctions">ListFunctions</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForPHPV3/lambda-2015-03-31/UpdateFunctionCode">UpdateFunctionCode</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForPHPV3/lambda-2015-03-31/UpdateFunctionConfiguration">UpdateFunctionConfiguration</a></p></li></ul></div>
                </li></ul></div>
        </dd>
    </dl></div>
        </dd>
    <dt>Python</dt><dd tab-id="python">
            <div class="variablelist">
     
<dl>
        <dt><b><span class="term">SDK for Python (Boto3)</span></b></dt>
        <dd>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>
                    There's more on GitHub. Find the complete example and learn how to set up and run in the
                    <a href="https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/python/example_code/lambda#code-examples" rel="noopener noreferrer" target="_blank"><span>AWS Code Examples Repository</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>.
                </p></div></div>
             
                <p>Define a Lambda handler that increments a number.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="python ">import logging

logger = logging.getLogger()
logger.setLevel(logging.INFO)


def lambda_handler(event, context):
    """
    Accepts an action and a single number, performs the specified action on the number,
    and returns the result. The only allowable action is 'increment'.

    :param event: The event dict that contains the parameters sent when the function
                  is invoked.
    :param context: The context in which the function is called.
    :return: The result of the action.
    """
    result = None
    action = event.get('action')
    if action == 'increment':
        result = event.get('number', 0) + 1
        logger.info('Calculated result of %s', result)
    else:
        logger.error("%s is not a valid action.", action)

    response = <span>{</span>'result': result}
    return response

</code></pre>
             
             
                <p>Define a second Lambda handler that performs arithmetic operations.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="python ">import logging
import os


logger = logging.getLogger()

# Define a list of Python lambda functions that are called by this AWS Lambda function.
ACTIONS = <span>{</span>
    'plus': lambda x, y: x + y,
    'minus': lambda x, y: x - y,
    'times': lambda x, y: x * y,
    'divided-by': lambda x, y: x / y}


def lambda_handler(event, context):
    """
    Accepts an action and two numbers, performs the specified action on the numbers,
    and returns the result.

    :param event: The event dict that contains the parameters sent when the function
                  is invoked.
    :param context: The context in which the function is called.
    :return: The result of the specified action.
    """
    # Set the log level based on a variable configured in the Lambda environment.
    logger.setLevel(os.environ.get('LOG_LEVEL', logging.INFO))
    logger.debug('Event: %s', event)

    action = event.get('action')
    func = ACTIONS.get(action)
    x = event.get('x')
    y = event.get('y')
    result = None
    try:
        if func is not None and x is not None and y is not None:
            result = func(x, y)
            logger.info("%s %s %s is %s", x, action, y, result)
        else:
            logger.error("I can't calculate %s %s %s.", x, action, y)
    except ZeroDivisionError:
        logger.warning("I can't divide %s by 0!", x)

    response = <span>{</span>'result': result}
    return response

</code></pre>
             
             
                <p>Create functions that wrap Lambda actions.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="python ">class LambdaWrapper:
    def __init__(self, lambda_client, iam_resource):
        self.lambda_client = lambda_client
        self.iam_resource = iam_resource

    @staticmethod
    def create_deployment_package(source_file, destination_file):
        """
        Creates a Lambda deployment package in .zip format in an in-memory buffer. This
        buffer can be passed directly to Lambda when creating the function.

        :param source_file: The name of the file that contains the Lambda handler
                            function.
        :param destination_file: The name to give the file when it's deployed to Lambda.
        :return: The deployment package.
        """
        buffer = io.BytesIO()
        with zipfile.ZipFile(buffer, 'w') as zipped:
            zipped.write(source_file, destination_file)
        buffer.seek(0)
        return buffer.read()

    def get_iam_role(self, iam_role_name):
        """
        Get an AWS Identity and Access Management (IAM) role.

        :param iam_role_name: The name of the role to retrieve.
        :return: The IAM role.
        """
        role = None
        try:
            temp_role = self.iam_resource.Role(iam_role_name)
            temp_role.load()
            role = temp_role
            logger.info("Got IAM role %s", role.name)
        except ClientError as err:
            if err.response['Error']['Code'] == 'NoSuchEntity':
                logger.info("IAM role %s does not exist.", iam_role_name)
            else:
                logger.error(
                    "Couldn't get IAM role %s. Here's why: %s: %s", iam_role_name,
                    err.response['Error']['Code'], err.response['Error']['Message'])
                raise
        return role

    def create_iam_role_for_lambda(self, iam_role_name):
        """
        Creates an IAM role that grants the Lambda function basic permissions. If a
        role with the specified name already exists, it is used for the demo.

        :param iam_role_name: The name of the role to create.
        :return: The role and a value that indicates whether the role is newly created.
        """
        role = self.get_iam_role(iam_role_name)
        if role is not None:
            return role, False

        lambda_assume_role_policy = <span>{</span>
            'Version': '2012-10-17',
            'Statement': [
                <span>{</span>
                    'Effect': 'Allow',
                    'Principal': <span>{</span>
                        'Service': 'lambda.amazonaws.com'
                    },
                    'Action': 'sts:AssumeRole'
                }
            ]
        }
        policy_arn = 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'

        try:
            role = self.iam_resource.create_role(
                RoleName=iam_role_name,
                AssumeRolePolicyDocument=json.dumps(lambda_assume_role_policy))
            logger.info("Created role %s.", role.name)
            role.attach_policy(PolicyArn=policy_arn)
            logger.info("Attached basic execution policy to role %s.", role.name)
        except ClientError as error:
            if error.response['Error']['Code'] == 'EntityAlreadyExists':
                role = self.iam_resource.Role(iam_role_name)
                logger.warning("The role %s already exists. Using it.", iam_role_name)
            else:
                logger.exception(
                    "Couldn't create role %s or attach policy %s.",
                    iam_role_name, policy_arn)
                raise

        return role, True

    def get_function(self, function_name):
        """
        Gets data about a Lambda function.

        :param function_name: The name of the function.
        :return: The function data.
        """
        response = None
        try:
            response = self.lambda_client.get_function(FunctionName=function_name)
        except ClientError as err:
            if err.response['Error']['Code'] == 'ResourceNotFoundException':
                logger.info("Function %s does not exist.", function_name)
            else:
                logger.error(
                    "Couldn't get function %s. Here's why: %s: %s", function_name,
                    err.response['Error']['Code'], err.response['Error']['Message'])
                raise
        return response

    def create_function(self, function_name, handler_name, iam_role, deployment_package):
        """
        Deploys a Lambda function.

        :param function_name: The name of the Lambda function.
        :param handler_name: The fully qualified name of the handler function. This
                             must include the file name and the function name.
        :param iam_role: The IAM role to use for the function.
        :param deployment_package: The deployment package that contains the function
                                   code in .zip format.
        :return: The Amazon Resource Name (ARN) of the newly created function.
        """
        try:
            response = self.lambda_client.create_function(
                FunctionName=function_name,
                Description="AWS Lambda doc example",
                Runtime='python3.8',
                Role=iam_role.arn,
                Handler=handler_name,
                Code=<span>{</span>'ZipFile': deployment_package},
                Publish=True)
            function_arn = response['FunctionArn']
            waiter = self.lambda_client.get_waiter('function_active_v2')
            waiter.wait(FunctionName=function_name)
            logger.info("Created function '%s' with ARN: '%s'.",
                        function_name, response['FunctionArn'])
        except ClientError:
            logger.error("Couldn't create function %s.", function_name)
            raise
        else:
            return function_arn

    def delete_function(self, function_name):
        """
        Deletes a Lambda function.

        :param function_name: The name of the function to delete.
        """
        try:
            self.lambda_client.delete_function(FunctionName=function_name)
        except ClientError:
            logger.exception("Couldn't delete function %s.", function_name)
            raise

    def invoke_function(self, function_name, function_params, get_log=False):
        """
        Invokes a Lambda function.

        :param function_name: The name of the function to invoke.
        :param function_params: The parameters of the function as a dict. This dict
                                is serialized to JSON before it is sent to Lambda.
        :param get_log: When true, the last 4 KB of the execution log are included in
                        the response.
        :return: The response from the function invocation.
        """
        try:
            response = self.lambda_client.invoke(
                FunctionName=function_name,
                Payload=json.dumps(function_params),
                LogType='Tail' if get_log else 'None')
            logger.info("Invoked function %s.", function_name)
        except ClientError:
            logger.exception("Couldn't invoke function %s.", function_name)
            raise
        return response

    def update_function_code(self, function_name, deployment_package):
        """
        Updates the code for a Lambda function by submitting a .zip archive that contains
        the code for the function.

        :param function_name: The name of the function to update.
        :param deployment_package: The function code to update, packaged as bytes in
                                   .zip format.
        :return: Data about the update, including the status.
        """
        try:
            response = self.lambda_client.update_function_code(
                FunctionName=function_name, ZipFile=deployment_package)
        except ClientError as err:
            logger.error(
                "Couldn't update function %s. Here's why: %s: %s", function_name,
                err.response['Error']['Code'], err.response['Error']['Message'])
            raise
        else:
            return response

    def update_function_configuration(self, function_name, env_vars):
        """
        Updates the environment variables for a Lambda function.

        :param function_name: The name of the function to update.
        :param env_vars: A dict of environment variables to update.
        :return: Data about the update, including the status.
        """
        try:
            response = self.lambda_client.update_function_configuration(
                FunctionName=function_name, Environment=<span>{</span>'Variables': env_vars})
        except ClientError as err:
            logger.error(
                "Couldn't update function configuration %s. Here's why: %s: %s", function_name,
                err.response['Error']['Code'], err.response['Error']['Message'])
            raise
        else:
            return response

    def list_functions(self):
        """
        Lists the Lambda functions for the current account.
        """
        try:
            func_paginator = self.lambda_client.get_paginator('list_functions')
            for func_page in func_paginator.paginate():
                for func in func_page['Functions']:
                    print(func['FunctionName'])
                    desc = func.get('Description')
                    if desc:
                        print(f"\t<span>{</span>desc}")
                    print(f"\t<span>{</span>func['Runtime']}: <span>{</span>func['Handler']}")
        except ClientError as err:
            logger.error(
                "Couldn't list functions. Here's why: %s: %s",
                err.response['Error']['Code'], err.response['Error']['Message'])
            raise

</code></pre>
             
             
                <p>Create a function that runs the scenario.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="python ">class UpdateFunctionWaiter(CustomWaiter):
    """A custom waiter that waits until a function is successfully updated."""
    def __init__(self, client):
        super().__init__(
            'UpdateSuccess', 'GetFunction',
            'Configuration.LastUpdateStatus',
            <span>{</span>'Successful': WaitState.SUCCESS, 'Failed': WaitState.FAILURE},
            client)

    def wait(self, function_name):
        self._wait(FunctionName=function_name)


def run_scenario(lambda_client, iam_resource, basic_file, calculator_file, lambda_name):
    """
    Runs the scenario.

    :param lambda_client: A Boto3 Lambda client.
    :param iam_resource: A Boto3 IAM resource.
    :param basic_file: The name of the file that contains the basic Lambda handler.
    :param calculator_file: The name of the file that contains the calculator Lambda handler.
    :param lambda_name: The name to give resources created for the scenario, such as the
                        IAM role and the Lambda function.
    """
    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')

    print('-'*88)
    print("Welcome to the AWS Lambda getting started with functions demo.")
    print('-'*88)

    wrapper = LambdaWrapper(lambda_client, iam_resource)

    print("Checking for IAM role for Lambda...")
    iam_role, should_wait = wrapper.create_iam_role_for_lambda(lambda_name)
    if should_wait:
        logger.info("Giving AWS time to create resources...")
        wait(10)

    print(f"Looking for function <span>{</span>lambda_name}...")
    function = wrapper.get_function(lambda_name)
    if function is None:
        print("Zipping the Python script into a deployment package...")
        deployment_package = wrapper.create_deployment_package(basic_file, f"<span>{</span>lambda_name}.py")
        print(f"...and creating the <span>{</span>lambda_name} Lambda function.")
        wrapper.create_function(
            lambda_name, f'<span>{</span>lambda_name}.lambda_handler', iam_role, deployment_package)
    else:
        print(f"Function <span>{</span>lambda_name} already exists.")
    print('-'*88)

    print(f"Let's invoke <span>{</span>lambda_name}. This function increments a number.")
    action_params = <span>{</span>
        'action': 'increment',
        'number': q.ask("Give me a number to increment: ", q.is_int)}
    print(f"Invoking <span>{</span>lambda_name}...")
    response = wrapper.invoke_function(lambda_name, action_params)
    print(f"Incrementing <span>{</span>action_params['number']} resulted in "
          f"<span>{</span>json.load(response['Payload'])}")
    print('-'*88)

    print(f"Let's update the function to an arithmetic calculator.")
    q.ask("Press Enter when you're ready.")
    print("Creating a new deployment package...")
    deployment_package = wrapper.create_deployment_package(calculator_file, f"<span>{</span>lambda_name}.py")
    print(f"...and updating the <span>{</span>lambda_name} Lambda function.")
    update_waiter = UpdateFunctionWaiter(lambda_client)
    wrapper.update_function_code(lambda_name, deployment_package)
    update_waiter.wait(lambda_name)
    print(f"This function uses an environment variable to control logging level.")
    print(f"Let's set it to DEBUG to get the most logging.")
    wrapper.update_function_configuration(
        lambda_name, <span>{</span>'LOG_LEVEL': logging.getLevelName(logging.DEBUG)})

    actions = ['plus', 'minus', 'times', 'divided-by']
    want_invoke = True
    while want_invoke:
        print(f"Let's invoke <span>{</span>lambda_name}. You can invoke these actions:")
        for index, action in enumerate(actions):
            print(f"<span>{</span>index + 1}: <span>{</span>action}")
        action_params = <span>{</span>}
        action_index = q.ask(
            "Enter the number of the action you want to take: ",
            q.is_int, q.in_range(1, len(actions)))
        action_params['action'] = actions[action_index - 1]
        print(f"You've chosen to invoke 'x <span>{</span>action_params['action']} y'.")
        action_params['x'] = q.ask("Enter a value for x: ", q.is_int)
        action_params['y'] = q.ask("Enter a value for y: ", q.is_int)
        print(f"Invoking <span>{</span>lambda_name}...")
        response = wrapper.invoke_function(lambda_name, action_params, True)
        print(f"Calculating <span>{</span>action_params['x']} <span>{</span>action_params['action']} <span>{</span>action_params['y']} "
              f"resulted in <span>{</span>json.load(response['Payload'])}")
        q.ask("Press Enter to see the logs from the call.")
        print(base64.b64decode(response['LogResult']).decode())
        want_invoke = q.ask("That was fun. Shall we do it again? (y/n) ", q.is_yesno)
    print('-'*88)

    if q.ask("Do you want to list all of the functions in your account? (y/n) ", q.is_yesno):
        wrapper.list_functions()
    print('-'*88)

    if q.ask("Ready to delete the function and role? (y/n) ", q.is_yesno):
        for policy in iam_role.attached_policies.all():
            policy.detach_role(RoleName=iam_role.name)
        iam_role.delete()
        print(f"Deleted role <span>{</span>lambda_name}.")
        wrapper.delete_function(lambda_name)
        print(f"Deleted function <span>{</span>lambda_name}.")

    print("\nThanks for watching!")
    print('-'*88)


if __name__ == '__main__':
    try:
        run_scenario(
            boto3.client('lambda'), boto3.resource('iam'), 'lambda_handler_basic.py',
            'lambda_handler_calculator.py', 'doc_example_lambda_calculator')
    except Exception:
        logging.exception("Something went wrong with the demo!")

</code></pre>
             
            <div class="itemizedlist">
                 
            <ul class="itemizedlist"><li class="listitem">
                    <p>For API details, see the following topics in <em>AWS SDK for Python (Boto3) API Reference</em>.</p>
                    <div class="itemizedlist">
                         
                         
                         
                         
                         
                         
                         
                    <ul class="itemizedlist"><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/boto3/lambda-2015-03-31/CreateFunction">CreateFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/boto3/lambda-2015-03-31/DeleteFunction">DeleteFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/boto3/lambda-2015-03-31/GetFunction">GetFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/boto3/lambda-2015-03-31/Invoke">Invoke</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/boto3/lambda-2015-03-31/ListFunctions">ListFunctions</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/boto3/lambda-2015-03-31/UpdateFunctionCode">UpdateFunctionCode</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/boto3/lambda-2015-03-31/UpdateFunctionConfiguration">UpdateFunctionConfiguration</a></p></li></ul></div>
                </li></ul></div>
        </dd>
    </dl></div>
        </dd>
    <dt>Ruby</dt><dd tab-id="ruby">
            <div class="variablelist">
     
<dl>
        <dt><b><span class="term">SDK for Ruby</span></b></dt>
        <dd>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>
                    There's more on GitHub. Find the complete example and learn how to set up and run in the
                    <a href="https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/ruby/example_code/lambda#code-examples" rel="noopener noreferrer" target="_blank"><span>AWS Code Examples Repository</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>.
                </p></div></div>
             
                <p>Set up pre-requisite IAM permissions for a Lambda function capable of writing logs.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="ruby ">  # Get an AWS Identity and Access Management (IAM) role.
  #
  # @param iam_role_name: The name of the role to retrieve.
  # @param action: Whether to create or destroy the IAM apparatus.
  # @return: The IAM role.
  def manage_iam(iam_role_name, action)
    role_policy = <span>{</span>
      'Version': "2012-10-17",
      'Statement': [
        <span>{</span>
          'Effect': "Allow",
          'Principal': <span>{</span>
            'Service': "lambda.amazonaws.com"
          },
          'Action': "sts:AssumeRole"
        }
      ]
    }
    case action
    when "create"
      role = $iam_client.create_role(
        role_name: iam_role_name,
        assume_role_policy_document: role_policy.to_json
      )
      $iam_client.attach_role_policy(
        <span>{</span>
          policy_arn: "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole",
          role_name: iam_role_name
        }
      )
      $iam_client.wait_until(:role_exists, <span>{</span> role_name: iam_role_name }) do |w|
        w.max_attempts = 5
        w.delay = 5
      end
      @logger.debug("Successfully created IAM role: #<span>{</span>role['role']['arn']}")
      @logger.debug("Enforcing a 10-second sleep to allow IAM role to activate fully.")
      sleep(10)
      return role, role_policy.to_json
    when "destroy"
      $iam_client.detach_role_policy(
        <span>{</span>
          policy_arn: "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole",
          role_name: iam_role_name
        }
      )
      $iam_client.delete_role(
        role_name: iam_role_name
      )
      @logger.debug("Detached policy &amp; deleted IAM role: #<span>{</span>iam_role_name}")
    else
      raise "Incorrect action provided. Must provide 'create' or 'destroy'"
    end
  rescue Aws::Lambda::Errors::ServiceException =&gt; e
    @logger.error("There was an error creating role or attaching policy:\n #<span>{</span>e.message}")
  end

</code></pre>
             
             
                <p>Define a Lambda handler that increments a number provided as an invocation parameter.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="ruby ">require "logger"

# A function that increments a whole number by one (1) and logs the result.
# Requires a manually-provided runtime parameter, 'number', which must be Int
#
# @param event [Hash] Parameters sent when the function is invoked
# @param context [Hash] Methods and properties that provide information
# about the invocation, function, and execution environment.
# @return incremented_number [String] The incremented number.
def lambda_handler(event:, context:)
  logger = Logger.new($stdout)
  log_level = ENV["LOG_LEVEL"]
  logger.level = case log_level
                 when "debug"
                   Logger::DEBUG
                 when "info"
                   Logger::INFO
                 else
                   Logger::ERROR
                 end
  logger.debug("This is a debug log message.")
  logger.info("This is an info log message. Code executed successfully!")
  number = event["number"].to_i
  incremented_number = number + 1
  logger.info("You provided #<span>{</span>number.round} and it was incremented to #<span>{</span>incremented_number.round}")
  incremented_number.round.to_s
end

</code></pre>
             
             
                <p>Zip your Lambda function into a deployment package.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="ruby ">  # Creates a Lambda deployment package in .zip format.
  # This zip can be passed directly as a string to Lambda when creating the function.
  #
  # @param source_file: The name of the object, without suffix, for the Lambda file and zip.
  # @return: The deployment package.
  def create_deployment_package(source_file)
    Dir.chdir(File.dirname(__FILE__))
    if File.exist?("lambda_function.zip")
      File.delete("lambda_function.zip")
      @logger.debug("Deleting old zip: lambda_function.zip")
    end
    Zip::File.open("lambda_function.zip", create: true) <span>{</span>
      |zipfile|
      zipfile.add("lambda_function.rb", "#<span>{</span>source_file}.rb")
    }
    @logger.debug("Zipping #<span>{</span>source_file}.rb into: lambda_function.zip.")
    File.read("lambda_function.zip").to_s
  rescue StandardError =&gt; e
    @logger.error("There was an error creating deployment package:\n #<span>{</span>e.message}")
  end

</code></pre>
             
             
                <p>Create a new Lambda function.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="ruby ">  # Deploys a Lambda function.
  #
  # @param function_name: The name of the Lambda function.
  # @param handler_name: The fully qualified name of the handler function. This
  #                      must include the file name and the function name.
  # @param role_arn: The IAM role to use for the function.
  # @param deployment_package: The deployment package that contains the function
  #                            code in .zip format.
  # @return: The Amazon Resource Name (ARN) of the newly created function.
  def create_function(function_name, handler_name, role_arn, deployment_package)
    response = @lambda_client.create_function(<span>{</span>
                                                role: role_arn.to_s,
                                                function_name: function_name,
                                                handler: handler_name,
                                                runtime: "ruby2.7",
                                                code: <span>{</span>
                                                  zip_file: deployment_package
                                                },
                                                environment: <span>{</span>
                                                  variables: <span>{</span>
                                                    "LOG_LEVEL" =&gt; "info"
                                                  }
                                                }
                                              })
    @lambda_client.wait_until(:function_active_v2, <span>{</span> function_name: function_name}) do |w|
      w.max_attempts = 5
      w.delay = 5
    end
    response
  rescue Aws::Lambda::Errors::ServiceException =&gt; e
    @logger.error("There was an error creating #<span>{</span>function_name}:\n #<span>{</span>e.message}")
  rescue Aws::Waiters::Errors::WaiterFailed =&gt; e
    @logger.error("Failed waiting for #<span>{</span>function_name} to activate:\n #<span>{</span>e.message}")
  end

</code></pre>
             
             
                <p>Invoke your Lambda function with optional runtime parameters.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="ruby ">  # Invokes a Lambda function.
  # @param function_name [String] The name of the function to invoke.
  # @param payload [nil] Payload containing runtime parameters.
  # @return [Object] The response from the function invocation.
  def invoke_function(function_name, payload = nil)
    params = <span>{</span> function_name: function_name}
    params[:payload] = payload unless payload.nil?
    @lambda_client.invoke(params)
  rescue Aws::Lambda::Errors::ServiceException =&gt; e
    @logger.error("There was an error executing #<span>{</span>function_name}:\n #<span>{</span>e.message}")
  end

</code></pre>
             
             
                <p>Update your Lambda function's configuration to inject a new environment variable.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="ruby ">  # Updates the environment variables for a Lambda function.
  # @param function_name: The name of the function to update.
  # @param log_level: The log level of the function.
  # @return: Data about the update, including the status.
  def update_function_configuration(function_name, log_level)
    @lambda_client.update_function_configuration(<span>{</span>
                                                   function_name: function_name,
                                                   environment: <span>{</span>
                                                     variables: <span>{</span>
                                                       "LOG_LEVEL" =&gt; log_level
                                                     }
                                                   }
                                                 })
    @lambda_client.wait_until(:function_updated_v2, <span>{</span> function_name: function_name}) do |w|
      w.max_attempts = 5
      w.delay = 5
    end
  rescue Aws::Lambda::Errors::ServiceException =&gt; e
    @logger.error("There was an error updating configurations for #<span>{</span>function_name}:\n #<span>{</span>e.message}")
  rescue Aws::Waiters::Errors::WaiterFailed =&gt; e
    @logger.error("Failed waiting for #<span>{</span>function_name} to activate:\n #<span>{</span>e.message}")
  end

</code></pre>
             
             
                <p>Update your Lambda function's code with a different deployment package containing different code.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="ruby ">  # Updates the code for a Lambda function by submitting a .zip archive that contains
  # the code for the function.

  # @param function_name: The name of the function to update.
  # @param deployment_package: The function code to update, packaged as bytes in
  #                            .zip format.
  # @return: Data about the update, including the status.
  def update_function_code(function_name, deployment_package)
    @lambda_client.update_function_code(
      function_name: function_name,
      zip_file: deployment_package
    )
    @lambda_client.wait_until(:function_updated_v2, <span>{</span> function_name: function_name}) do |w|
      w.max_attempts = 5
      w.delay = 5
    end
  rescue Aws::Lambda::Errors::ServiceException =&gt; e
    @logger.error("There was an error updating function code for: #<span>{</span>function_name}:\n #<span>{</span>e.message}")
    nil
  rescue Aws::Waiters::Errors::WaiterFailed =&gt; e
    @logger.error("Failed waiting for #<span>{</span>function_name} to update:\n #<span>{</span>e.message}")
  end

</code></pre>
             
             
                <p>List all existing Lambda functions using the built-in paginator.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="ruby ">  # Lists the Lambda functions for the current account.
  def list_functions
    functions = []
    @lambda_client.list_functions.each do |response|
      response["functions"].each do |function|
        functions.append(function["function_name"])
      end
    end
    functions
  rescue Aws::Lambda::Errors::ServiceException =&gt; e
    @logger.error("There was an error executing #<span>{</span>function_name}:\n #<span>{</span>e.message}")
  end

</code></pre>
             
             
                <p>Delete a specific Lambda function.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="ruby ">  # Deletes a Lambda function.
  # @param function_name: The name of the function to delete.
  def delete_function(function_name)
    print "Deleting function: #<span>{</span>function_name}..."
    @lambda_client.delete_function(
      function_name: function_name
    )
    print "Done!".green
  rescue Aws::Lambda::Errors::ServiceException =&gt; e
    @logger.error("There was an error deleting #<span>{</span>function_name}:\n #<span>{</span>e.message}")
  end

</code></pre>
             
            <div class="itemizedlist">
                 
            <ul class="itemizedlist"><li class="listitem">
                    <p>For API details, see the following topics in <em>AWS SDK for Ruby API Reference</em>.</p>
                    <div class="itemizedlist">
                         
                         
                         
                         
                         
                         
                         
                    <ul class="itemizedlist"><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForRubyV3/lambda-2015-03-31/CreateFunction">CreateFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForRubyV3/lambda-2015-03-31/DeleteFunction">DeleteFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForRubyV3/lambda-2015-03-31/GetFunction">GetFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForRubyV3/lambda-2015-03-31/Invoke">Invoke</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForRubyV3/lambda-2015-03-31/ListFunctions">ListFunctions</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForRubyV3/lambda-2015-03-31/UpdateFunctionCode">UpdateFunctionCode</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/goto/SdkForRubyV3/lambda-2015-03-31/UpdateFunctionConfiguration">UpdateFunctionConfiguration</a></p></li></ul></div>
                </li></ul></div>
        </dd>
    </dl></div>
        </dd>
    <dt>Rust</dt><dd tab-id="rust">
            <div class="variablelist">
     
<dl>
        <dt><b><span class="term">SDK for Rust</span></b></dt>
        <dd>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>This documentation is for an SDK in preview release. The SDK is subject to change and should not be used in production.</p></div></div>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>
                    There's more on GitHub. Find the complete example and learn how to set up and run in the
                    <a href="https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/rust_dev_preview/examples/lambda#code-examples" rel="noopener noreferrer" target="_blank"><span>AWS Code Examples Repository</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>.
                </p></div></div>
             
                <p>The Cargo.toml with dependencies used in this scenario.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="rust ">[package]
name = "lambda-code-examples"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
aws-config = <span>{</span> git = "https://github.com/awslabs/aws-sdk-rust", branch = "next" }
aws-sdk-ec2 = <span>{</span> git = "https://github.com/awslabs/aws-sdk-rust", branch = "next" }
aws-sdk-iam = <span>{</span> git = "https://github.com/awslabs/aws-sdk-rust", branch = "next" }
aws-sdk-lambda = <span>{</span> git = "https://github.com/awslabs/aws-sdk-rust", branch = "next" }
aws-sdk-s3 = <span>{</span> git = "https://github.com/awslabs/aws-sdk-rust", branch = "next" }
aws-smithy-types = <span>{</span> git = "https://github.com/awslabs/aws-sdk-rust", branch = "next" }
aws-types = <span>{</span> git = "https://github.com/awslabs/aws-sdk-rust", branch = "next" }
clap = <span>{</span> version = "~4.2", features = ["derive"] }
tokio = <span>{</span> version = "1.20.1", features = ["full"] }
tracing-subscriber = <span>{</span> version = "0.3.15", features = ["env-filter"] }
tracing = "0.1.37"
serde_json = "1.0.94"
anyhow = "1.0.71"
uuid = <span>{</span> version = "1.3.3", features = ["v4"] }
lambda_runtime = "0.8.0"
serde = "1.0.164"

</code></pre>
             
             
                <p>A collection of utilities that streamline calling Lambda for this scenario. This file is src/ations.rs in the crate.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="rust ">/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0.
 */

use anyhow::anyhow;
use aws_sdk_iam::operation::delete_role::DeleteRoleOutput;
use aws_sdk_lambda::<span>{</span>
    operation::<span>{</span>
        delete_function::DeleteFunctionOutput, get_function::GetFunctionOutput,
        invoke::InvokeOutput, list_functions::ListFunctionsOutput,
        update_function_code::UpdateFunctionCodeOutput,
        update_function_configuration::UpdateFunctionConfigurationOutput,
    },
    primitives::ByteStream,
    types::<span>{</span>Environment, FunctionCode, LastUpdateStatus, State},
};
use aws_sdk_s3::<span>{</span>
    operation::<span>{</span>delete_bucket::DeleteBucketOutput, delete_object::DeleteObjectOutput},
    types::CreateBucketConfiguration,
};
use aws_smithy_types::Blob;
use serde::<span>{</span>ser::SerializeMap, Serialize};
use std::<span>{</span>path::PathBuf, str::FromStr, time::Duration};
use tracing::<span>{</span>debug, error, info, warn};

/* Operation describes  */
#[derive(Clone, Copy, Debug, Serialize)]
pub enum Operation <span>{</span>
    #[serde(rename = "plus")]
    Plus,
    #[serde(rename = "minus")]
    Minus,
    #[serde(rename = "times")]
    Times,
    #[serde(rename = "divided-by")]
    DividedBy,
}

impl FromStr for Operation <span>{</span>
    type Err = anyhow::Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; <span>{</span>
        match s <span>{</span>
            "plus" =&gt; Ok(Operation::Plus),
            "minus" =&gt; Ok(Operation::Minus),
            "times" =&gt; Ok(Operation::Times),
            "divided-by" =&gt; Ok(Operation::DividedBy),
            _ =&gt; Err(anyhow!("Unknown operation <span>{</span>s}")),
        }
    }
}

impl ToString for Operation <span>{</span>
    fn to_string(&amp;self) -&gt; String <span>{</span>
        match self <span>{</span>
            Operation::Plus =&gt; "plus".to_string(),
            Operation::Minus =&gt; "minus".to_string(),
            Operation::Times =&gt; "times".to_string(),
            Operation::DividedBy =&gt; "divided-by".to_string(),
        }
    }
}

/**
 * InvokeArgs will be serialized as JSON and sent to the AWS Lambda handler.
 */
#[derive(Debug)]
pub enum InvokeArgs <span>{</span>
    Increment(i32),
    Arithmetic(Operation, i32, i32),
}

impl Serialize for InvokeArgs <span>{</span>
    fn serialize&lt;S&gt;(&amp;self, serializer: S) -&gt; Result&lt;S::Ok, S::Error&gt;
    where
        S: serde::Serializer,
    <span>{</span>
        match self <span>{</span>
            InvokeArgs::Increment(i) =&gt; serializer.serialize_i32(*i),
            InvokeArgs::Arithmetic(o, i, j) =&gt; <span>{</span>
                let mut map: S::SerializeMap = serializer.serialize_map(Some(3))?;
                map.serialize_key(&amp;"op".to_string())?;
                map.serialize_value(&amp;o.to_string())?;
                map.serialize_key(&amp;"i".to_string())?;
                map.serialize_value(&amp;i)?;
                map.serialize_key(&amp;"j".to_string())?;
                map.serialize_value(&amp;j)?;
                map.end()
            }
        }
    }
}

/** A policy document allowing Lambda to execute this function on the account's behalf. */
const ROLE_POLICY_DOCUMENT: &amp;str = r#"<span>{</span>
    "Version": "2012-10-17",
    "Statement": [
        <span>{</span>
            "Effect": "Allow",
            "Principal": <span>{</span> "Service": "lambda.amazonaws.com" },
            "Action": "sts:AssumeRole"
        }
    ]
}"#;

/**
 * A LambdaManager gathers all the resources necessary to run the Lambda example scenario.
 * This includes instantiated aws_sdk clients and details of resource names.
 */
pub struct LambdaManager <span>{</span>
    iam_client: aws_sdk_iam::Client,
    lambda_client: aws_sdk_lambda::Client,
    s3_client: aws_sdk_s3::Client,
    lambda_name: String,
    role_name: String,
    bucket: String,
    own_bucket: bool,
}

// These unit type structs provide nominal typing on top of String parameters for LambdaManager::new
pub struct LambdaName(pub String);
pub struct RoleName(pub String);
pub struct Bucket(pub String);
pub struct OwnBucket(pub bool);

impl LambdaManager <span>{</span>
    pub fn new(
        iam_client: aws_sdk_iam::Client,
        lambda_client: aws_sdk_lambda::Client,
        s3_client: aws_sdk_s3::Client,
        lambda_name: LambdaName,
        role_name: RoleName,
        bucket: Bucket,
        own_bucket: OwnBucket,
    ) -&gt; Self <span>{</span>
        Self <span>{</span>
            iam_client,
            lambda_client,
            s3_client,
            lambda_name: lambda_name.0,
            role_name: role_name.0,
            bucket: bucket.0,
            own_bucket: own_bucket.0,
        }
    }

    /**
     * Load the AWS configuration from the environment.
     * Look up lambda_name and bucket if none are given, or generate a random name if not present in the environment.
     * If the bucket name is provided, the caller needs to have created the bucket.
     * If the bucket name is generated, it will be created.
     */
    pub async fn load_from_env(lambda_name: Option&lt;String&gt;, bucket: Option&lt;String&gt;) -&gt; Self <span>{</span>
        let sdk_config = aws_config::load_from_env().await;
        let lambda_name = LambdaName(lambda_name.unwrap_or_else(|| <span>{</span>
            std::env::var("LAMBDA_NAME").unwrap_or_else(|_| "rust_lambda_example".to_string())
        }));
        let role_name = RoleName(format!("<span>{</span>}_role", lambda_name.0));
        let (bucket, own_bucket) =
            match bucket <span>{</span>
                Some(bucket) =&gt; (Bucket(bucket), false),
                None =&gt; (
                    Bucket(std::env::var("LAMBDA_BUCKET").unwrap_or_else(|_| <span>{</span>
                        format!("rust-lambda-example-<span>{</span>}", uuid::Uuid::new_v4())
                    })),
                    true,
                ),
            };

        let s3_client = aws_sdk_s3::Client::new(&amp;sdk_config);

        if own_bucket <span>{</span>
            info!("Creating bucket for demo: <span>{</span>}", bucket.0);
            s3_client
                .create_bucket()
                .bucket(bucket.0.clone())
                .create_bucket_configuration(
                    CreateBucketConfiguration::builder()
                        .location_constraint(aws_sdk_s3::types::BucketLocationConstraint::from(
                            sdk_config.region().unwrap().as_ref(),
                        ))
                        .build(),
                )
                .send()
                .await
                .unwrap();
        }

        Self::new(
            aws_sdk_iam::Client::new(&amp;sdk_config),
            aws_sdk_lambda::Client::new(&amp;sdk_config),
            s3_client,
            lambda_name,
            role_name,
            bucket,
            OwnBucket(own_bucket),
        )
    }

    // snippet-start:[lambda.rust.scenario.prepare_function]
    /**
     * Upload function code from a path to a zip file.
     * The zip file must have an AL2 Linux-compatible binary called `bootstrap`.
     * The easiest way to create such a zip is to use `cargo lambda build --output-format Zip`.
     */
    async fn prepare_function(
        &amp;self,
        zip_file: PathBuf,
        key: Option&lt;String&gt;,
    ) -&gt; Result&lt;FunctionCode, anyhow::Error&gt; <span>{</span>
        let body = ByteStream::read_from().path(zip_file).build().await?;

        let key = key.unwrap_or_else(|| format!("<span>{</span>}_code", self.lambda_name));

        info!("Uploading function code to s3://<span>{</span>}/<span>{</span>}", self.bucket, key);
        let _ = self
            .s3_client
            .put_object()
            .bucket(self.bucket.clone())
            .key(key.clone())
            .body(body)
            .send()
            .await?;

        Ok(FunctionCode::builder()
            .s3_bucket(self.bucket.clone())
            .s3_key(key)
            .build())
    }
    // snippet-end:[lambda.rust.scenario.prepare_function]

    // snippet-start:[lambda.rust.scenario.create_function]
    /**
     * Create a function, uploading from a zip file.
     */
    pub async fn create_function(&amp;self, zip_file: PathBuf) -&gt; Result&lt;String, anyhow::Error&gt; <span>{</span>
        let code = self.prepare_function(zip_file, None).await?;

        let key = code.s3_key().unwrap().to_string();

        self.create_role().await;

        let role = self
            .iam_client
            .create_role()
            .role_name(self.role_name.clone())
            .assume_role_policy_document(ROLE_POLICY_DOCUMENT)
            .send()
            .await?;

        info!("Created iam role, waiting 15s for it to become active");
        tokio::time::sleep(Duration::from_secs(15)).await;

        info!("Creating lambda function <span>{</span>}", self.lambda_name);
        let _ = self
            .lambda_client
            .create_function()
            .function_name(self.lambda_name.clone())
            .code(code)
            .role(role.role().map(|r| r.arn()).unwrap_or_default())
            .runtime(aws_sdk_lambda::types::Runtime::Providedal2)
            .handler("_unused")
            .send()
            .await
            .map_err(anyhow::Error::from)?;

        self.wait_for_function_ready().await?;

        self.lambda_client
            .publish_version()
            .function_name(self.lambda_name.clone())
            .send()
            .await?;

        Ok(key)
    }
    // snippet-end:[lambda.rust.scenario.create_function]

    /**
     * Create an IAM execution role for the managed Lambda function.
     */
    async fn create_role(&amp;self) <span>{</span>
        info!("Creating execution role for function");
        if let Ok(_response) = self
            .iam_client
            .get_role()
            .role_name(self.role_name.clone())
            .send()
            .await
        <span>{</span>
            let delete_response = self
                .iam_client
                .delete_role()
                .role_name(self.role_name.clone())
                .send()
                .await;
            match delete_response <span>{</span>
                Ok(_) =&gt; debug!("Deleted role first"),
                Err(_) =&gt; <span>{</span>
                    warn!("Failed to delete role, will probably fail to create the new role")
                }
            }
        }
    }

    /**
     * Poll `is_function_ready` with a 1-second delay. It returns when the function is ready or when there's an error checking the function's state.
     */
    pub async fn wait_for_function_ready(&amp;self) -&gt; Result&lt;(), anyhow::Error&gt; <span>{</span>
        info!("Waiting for function");
        while !self.is_function_ready(None).await? <span>{</span>
            info!("Function is not ready, sleeping 1s");
            tokio::time::sleep(Duration::from_secs(1)).await;
        }
        Ok(())
    }

    /**
     * Check if a Lambda function is ready to be invoked.
     * A Lambda function is ready for this scenario when its state is active and its LastUpdateStatus is Successful.
     * Additionally, if a sha256 is provided, the function must have that as its current code hash.
     * Any missing properties or failed requests will be reported as an Err.
     */
    async fn is_function_ready(
        &amp;self,
        expected_code_sha256: Option&lt;&amp;str&gt;,
    ) -&gt; Result&lt;bool, anyhow::Error&gt; <span>{</span>
        match self.get_function().await <span>{</span>
            Ok(func) =&gt; <span>{</span>
                if let Some(config) = func.configuration() <span>{</span>
                    if let Some(state) = config.state() <span>{</span>
                        info!(?state, "Checking if function is active");
                        if !matches!(state, State::Active) <span>{</span>
                            return Ok(false);
                        }
                    }
                    match config.last_update_status() <span>{</span>
                        Some(last_update_status) =&gt; <span>{</span>
                            info!(?last_update_status, "Checking if function is ready");
                            match last_update_status <span>{</span>
                                LastUpdateStatus::Successful =&gt; <span>{</span>
                                    // continue
                                }
                                LastUpdateStatus::Failed | LastUpdateStatus::InProgress =&gt; <span>{</span>
                                    return Ok(false);
                                }
                                LastUpdateStatus::Unknown(status_variant) =&gt; <span>{</span>
                                    warn!(?status_variant, "LastUpdateStatus unknown");
                                    return Err(anyhow!(
                                        "Unknown LastUpdateStatus, fn config is <span>{</span>config:?}"
                                    ));
                                }
                                _ =&gt; <span>{</span>
                                    error!("Unmatched LastUpdateStatus");
                                    return Err(anyhow!("Unmatched LastUpdateStatus"));
                                }
                            }
                        }
                        None =&gt; <span>{</span>
                            warn!("Missing last update status");
                            return Ok(false);
                        }
                    };
                    if expected_code_sha256.is_none() <span>{</span>
                        return Ok(true);
                    }
                    if let Some(code_sha256) = config.code_sha256() <span>{</span>
                        return Ok(code_sha256 == expected_code_sha256.unwrap_or_default());
                    }
                }
            }
            Err(e) =&gt; <span>{</span>
                warn!(?e, "Could not get function while waiting");
            }
        }
        Ok(false)
    }

    // snippet-start:[lambda.rust.scenario.get_function]
    /** Get the Lambda function with this Manager's name. */
    pub async fn get_function(&amp;self) -&gt; Result&lt;GetFunctionOutput, anyhow::Error&gt; <span>{</span>
        info!("Getting lambda function");
        self.lambda_client
            .get_function()
            .function_name(self.lambda_name.clone())
            .send()
            .await
            .map_err(anyhow::Error::from)
    }
    // snippet-end:[lambda.rust.scenario.get_function]

    // snippet-start:[lambda.rust.scenario.list_functions]
    /** List all Lambda functions in the current Region. */
    pub async fn list_functions(&amp;self) -&gt; Result&lt;ListFunctionsOutput, anyhow::Error&gt; <span>{</span>
        info!("Listing lambda functions");
        self.lambda_client
            .list_functions()
            .send()
            .await
            .map_err(anyhow::Error::from)
    }
    // snippet-end:[lambda.rust.scenario.list_functions]

    // snippet-start:[lambda.rust.scenario.invoke]
    /** Invoke the lambda function using calculator InvokeArgs. */
    pub async fn invoke(&amp;self, args: InvokeArgs) -&gt; Result&lt;InvokeOutput, anyhow::Error&gt; <span>{</span>
        info!(?args, "Invoking <span>{</span>}", self.lambda_name);
        let payload = serde_json::to_string(&amp;args)?;
        debug!(?payload, "Sending payload");
        self.lambda_client
            .invoke()
            .function_name(self.lambda_name.clone())
            .payload(Blob::new(payload))
            .send()
            .await
            .map_err(anyhow::Error::from)
    }
    // snippet-end:[lambda.rust.scenario.invoke]

    // snippet-start:[lambda.rust.scenario.update_function_code]
    /** Given a Path to a zip file, update the function's code and wait for the update to finish. */
    pub async fn update_function_code(
        &amp;self,
        zip_file: PathBuf,
        key: String,
    ) -&gt; Result&lt;UpdateFunctionCodeOutput, anyhow::Error&gt; <span>{</span>
        let function_code = self.prepare_function(zip_file, Some(key)).await?;

        info!("Updating code for <span>{</span>}", self.lambda_name);
        let update = self
            .lambda_client
            .update_function_code()
            .function_name(self.lambda_name.clone())
            .s3_bucket(self.bucket.clone())
            .s3_key(function_code.s3_key().unwrap().to_string())
            .send()
            .await
            .map_err(anyhow::Error::from)?;

        self.wait_for_function_ready().await?;

        Ok(update)
    }
    // snippet-end:[lambda.rust.scenario.update_function_code]

    // snippet-start:[lambda.rust.scenario.update_function_configuration]
    /** Update the environment for a function. */
    pub async fn update_function_configuration(
        &amp;self,
        environment: Environment,
    ) -&gt; Result&lt;UpdateFunctionConfigurationOutput, anyhow::Error&gt; <span>{</span>
        info!(
            ?environment,
            "Updating environment for <span>{</span>}", self.lambda_name
        );
        let updated = self
            .lambda_client
            .update_function_configuration()
            .function_name(self.lambda_name.clone())
            .environment(environment)
            .send()
            .await
            .map_err(anyhow::Error::from)?;

        self.wait_for_function_ready().await?;

        Ok(updated)
    }
    // snippet-end:[lambda.rust.scenario.update_function_configuration]

    // snippet-start:[lambda.rust.scenario.delete_function]
    /** Delete a function and its role, and if possible or necessary, its associated code object and bucket. */
    pub async fn delete_function(
        &amp;self,
        location: Option&lt;String&gt;,
    ) -&gt; (
        Result&lt;DeleteFunctionOutput, anyhow::Error&gt;,
        Result&lt;DeleteRoleOutput, anyhow::Error&gt;,
        Option&lt;Result&lt;DeleteObjectOutput, anyhow::Error&gt;&gt;,
    ) <span>{</span>
        info!("Deleting lambda function <span>{</span>}", self.lambda_name);
        let delete_function = self
            .lambda_client
            .delete_function()
            .function_name(self.lambda_name.clone())
            .send()
            .await
            .map_err(anyhow::Error::from);

        info!("Deleting iam role <span>{</span>}", self.role_name);
        let delete_role = self
            .iam_client
            .delete_role()
            .role_name(self.role_name.clone())
            .send()
            .await
            .map_err(anyhow::Error::from);

        let delete_object: Option&lt;Result&lt;DeleteObjectOutput, anyhow::Error&gt;&gt; =
            if let Some(location) = location <span>{</span>
                info!("Deleting object <span>{</span>location}");
                Some(
                    self.s3_client
                        .delete_object()
                        .bucket(self.bucket.clone())
                        .key(location)
                        .send()
                        .await
                        .map_err(anyhow::Error::from),
                )
            } else <span>{</span>
                info!(?location, "Skipping delete object");
                None
            };

        (delete_function, delete_role, delete_object)
    }
    // snippet-end:[lambda.rust.scenario.delete_function]

    pub async fn cleanup(
        &amp;self,
        location: Option&lt;String&gt;,
    ) -&gt; (
        (
            Result&lt;DeleteFunctionOutput, anyhow::Error&gt;,
            Result&lt;DeleteRoleOutput, anyhow::Error&gt;,
            Option&lt;Result&lt;DeleteObjectOutput, anyhow::Error&gt;&gt;,
        ),
        Option&lt;Result&lt;DeleteBucketOutput, anyhow::Error&gt;&gt;,
    ) <span>{</span>
        let delete_function = self.delete_function(location).await;

        let delete_bucket = if self.own_bucket <span>{</span>
            info!("Deleting bucket <span>{</span>}", self.bucket);
            if delete_function.2.is_none() || delete_function.2.as_ref().unwrap().is_ok() <span>{</span>
                Some(
                    self.s3_client
                        .delete_bucket()
                        .bucket(self.bucket.clone())
                        .send()
                        .await
                        .map_err(anyhow::Error::from),
                )
            } else <span>{</span>
                None
            }
        } else <span>{</span>
            info!("No bucket to clean up");
            None
        };

        (delete_function, delete_bucket)
    }
}

/**
 * Testing occurs primarily as an integration test running the `scenario` bin successfully.
 * Each action relies deeply on the internal workings and state of Amazon Simple Storage Service (Amazon S3), Lambda, and IAM working together.
 * It is therefore infeasible to mock the clients to test the individual actions.
 */
#[cfg(test)]
mod test <span>{</span>
    use super::<span>{</span>InvokeArgs, Operation};
    use serde_json::json;

    /** Make sure that the JSON output of serializing InvokeArgs is what's expected by the calculator. */
    #[test]
    fn test_serialize() <span>{</span>
        assert_eq!(json!(InvokeArgs::Increment(5)), 5);
        assert_eq!(
            json!(InvokeArgs::Arithmetic(Operation::Plus, 5, 7)).to_string(),
            r#"<span>{</span>"i":5,"j":7,"op":"plus"}"#.to_string(),
        );
    }
}

</code></pre>
             
             
                <p>A binary to run the scenario from front to end, using command line flags to control some behavior. This file is src/bin/scenario.rs in the crate.</p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="rust ">/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0.
 */

/*
## Service actions

Service actions wrap the SDK call, taking a client and any specific parameters necessary for the call.

* CreateFunction
* GetFunction
* ListFunctions
* Invoke
* UpdateFunctionCode
* UpdateFunctionConfiguration
* DeleteFunction

## Scenario
A scenario runs at a command prompt and prints output to the user on the result of each service action. A scenario can run in one of two ways: straight through, printing out progress as it goes, or as an interactive question/answer script.

## Getting started with functions

Use an SDK to manage AWS Lambda functions: create a function, invoke it, update its code, invoke it again, view its output and logs, and delete it.

This scenario uses two Lambda handlers:
_Note: Handlers don't use AWS SDK API calls._

The increment handler is straightforward:

1. It accepts a number, increments it, and returns the new value.
2. It performs simple logging of the result.

The arithmetic handler is more complex:
1. It accepts a set of actions ['plus', 'minus', 'times', 'divided-by'] and two numbers, and returns the result of the calculation.
2. It uses an environment variable to control log level (such as DEBUG, INFO, WARNING, ERROR).
It logs a few things at different levels, such as:
    * DEBUG: Full event data.
    * INFO: The calculation result.
    * WARN~ING~: When a divide by zero error occurs.
    * This will be the typical `RUST_LOG` variable.


The steps of the scenario are:

1. Create an AWS Identity and Access Management (IAM) role that meets the following requirements:
    * Has an assume_role policy that grants 'lambda.amazonaws.com' the 'sts:AssumeRole' action.
    * Attaches the 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole' managed role.
    * _You must wait for ~10 seconds after the role is created before you can use it!_
2. Create a function (CreateFunction) for the increment handler by packaging it as a zip and doing one of the following:
    * Adding it with CreateFunction Code.ZipFile.
    * --or--
    * Uploading it to Amazon Simple Storage Service (Amazon S3) and adding it with CreateFunction Code.S3Bucket/S3Key.
    * _Note: Zipping the file does not have to be done in code._
    * If you have a waiter, use it to wait until the function is active. Otherwise, call GetFunction until State is Active.
3. Invoke the function with a number and print the result.
4. Update the function (UpdateFunctionCode) to the arithmetic handler by packaging it as a zip and doing one of the following:
    * Adding it with UpdateFunctionCode ZipFile.
    * --or--
    * Uploading it to Amazon S3 and adding it with UpdateFunctionCode S3Bucket/S3Key.
5. Call GetFunction until Configuration.LastUpdateStatus is 'Successful' (or 'Failed').
6. Update the environment variable by calling UpdateFunctionConfiguration and pass it a log level, such as:
    * Environment=<span>{</span>'Variables': <span>{</span>'RUST_LOG': 'TRACE'}}
7. Invoke the function with an action from the list and a couple of values. Include LogType='Tail' to get logs in the result. Print the result of the calculation and the log.
8. [Optional] Invoke the function to provoke a divide-by-zero error and show the log result.
9. List all functions for the account, using pagination (ListFunctions).
10. Delete the function (DeleteFunction).
11. Delete the role.

Each step should use the function created in Service Actions to abstract calling the SDK.
 */

use aws_sdk_lambda::<span>{</span>operation::invoke::InvokeOutput, types::Environment};
use clap::Parser;
use std::<span>{</span>collections::HashMap, path::PathBuf};
use tracing::<span>{</span>debug, info, warn};
use tracing_subscriber::EnvFilter;

use lambda_code_examples::actions::<span>{</span>
    InvokeArgs::<span>{</span>Arithmetic, Increment},
    LambdaManager, Operation,
};

#[derive(Debug, Parser)]
pub struct Opt <span>{</span>
    /// The AWS Region.
    #[structopt(short, long)]
    pub region: Option&lt;String&gt;,

    // The bucket to use for the FunctionCode.
    #[structopt(short, long)]
    pub bucket: Option&lt;String&gt;,

    // The name of the Lambda function.
    #[structopt(short, long)]
    pub lambda_name: Option&lt;String&gt;,

    // The number to increment.
    #[structopt(short, long, default_value = "12")]
    pub inc: i32,

    // The left operand.
    #[structopt(long, default_value = "19")]
    pub num_a: i32,

    // The right operand.
    #[structopt(long, default_value = "23")]
    pub num_b: i32,

    // The arithmetic operation.
    #[structopt(short, long, default_value = "plus")]
    pub operation: Operation,

    #[structopt(long)]
    pub cleanup: Option&lt;bool&gt;,

    #[structopt(long)]
    pub no_cleanup: Option&lt;bool&gt;,
}

fn code_path(lambda: &amp;str) -&gt; PathBuf <span>{</span>
    PathBuf::from(format!("../target/lambda/<span>{</span>lambda}/bootstrap.zip"))
}

// snippet-start:[lambda.rust.scenario.log_invoke_output]
fn log_invoke_output(invoke: &amp;InvokeOutput, message: &amp;str) <span>{</span>
    if let Some(payload) = invoke.payload().cloned() <span>{</span>
        let payload = String::from_utf8(payload.into_inner());
        info!(?payload, message);
    } else <span>{</span>
        info!("Could not extract payload")
    }
    if let Some(logs) = invoke.log_result() <span>{</span>
        debug!(?logs, "Invoked function logs")
    } else <span>{</span>
        debug!("Invoked function had no logs")
    }
}
// snippet-end:[lambda.rust.scenario.log_invoke_output]

async fn main_block(
    opt: &amp;Opt,
    manager: &amp;LambdaManager,
    code_location: String,
) -&gt; Result&lt;(), anyhow::Error&gt; <span>{</span>
    let invoke = manager.invoke(Increment(opt.inc)).await?;
    log_invoke_output(&amp;invoke, "Invoked function configured as increment");

    let update_code = manager
        .update_function_code(code_path("arithmetic"), code_location.clone())
        .await?;

    let code_sha256 = update_code.code_sha256().unwrap_or("Unknown SHA");
    info!(?code_sha256, "Updated function code with arithmetic.zip");

    let arithmetic_args = Arithmetic(opt.operation, opt.num_a, opt.num_b);
    let invoke = manager.invoke(arithmetic_args).await?;
    log_invoke_output(&amp;invoke, "Invoked function configured as arithmetic");

    let update = manager
        .update_function_configuration(
            Environment::builder()
                .set_variables(Some(HashMap::from([(
                    "RUST_LOG".to_string(),
                    "trace".to_string(),
                )])))
                .build(),
        )
        .await?;
    let updated_environment = update.environment();
    info!(?updated_environment, "Updated function configuration");

    let invoke = manager
        .invoke(Arithmetic(opt.operation, opt.num_a, opt.num_b))
        .await?;
    log_invoke_output(
        &amp;invoke,
        "Invoked function configured as arithmetic with increased logging",
    );

    let invoke = manager
        .invoke(Arithmetic(Operation::DividedBy, opt.num_a, 0))
        .await?;
    log_invoke_output(
        &amp;invoke,
        "Invoked function configured as arithmetic with divide by zero",
    );

    Ok::&lt;(), anyhow::Error&gt;(())
}

#[tokio::main]
async fn main() <span>{</span>
    tracing_subscriber::fmt()
        .without_time()
        .with_file(true)
        .with_line_number(true)
        .with_env_filter(EnvFilter::from_default_env())
        .init();

    let opt = Opt::parse();
    let manager = LambdaManager::load_from_env(opt.lambda_name.clone(), opt.bucket.clone()).await;

    let key = match manager.create_function(code_path("increment")).await <span>{</span>
        Ok(init) =&gt; <span>{</span>
            info!(?init, "Created function, initially with increment.zip");
            let run_block = main_block(&amp;opt, &amp;manager, init.clone()).await;
            info!(?run_block, "Finished running example, cleaning up");
            Some(init)
        }
        Err(err) =&gt; <span>{</span>
            warn!(?err, "Error happened when initializing function");
            None
        }
    };

    if Some(false) == opt.cleanup || Some(true) == opt.no_cleanup <span>{</span>
        info!("Skipping cleanup")
    } else <span>{</span>
        let delete = manager.cleanup(key).await;
        info!(?delete, "Deleted function &amp; cleaned up resources");
    }
}

</code></pre>
             
            <div class="itemizedlist">
                 
            <ul class="itemizedlist"><li class="listitem">
                    <p>For API details, see the following topics in <em>AWS SDK for Rust API reference</em>.</p>
                    <div class="itemizedlist">
                         
                         
                         
                         
                         
                         
                         
                    <ul class="itemizedlist"><li class="listitem"><p><a href="https://docs.rs/releases/search?query=aws-sdk" rel="noopener noreferrer" target="_blank"><span>CreateFunction</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://docs.rs/releases/search?query=aws-sdk" rel="noopener noreferrer" target="_blank"><span>DeleteFunction</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://docs.rs/releases/search?query=aws-sdk" rel="noopener noreferrer" target="_blank"><span>GetFunction</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://docs.rs/releases/search?query=aws-sdk" rel="noopener noreferrer" target="_blank"><span>Invoke</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://docs.rs/releases/search?query=aws-sdk" rel="noopener noreferrer" target="_blank"><span>ListFunctions</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://docs.rs/releases/search?query=aws-sdk" rel="noopener noreferrer" target="_blank"><span>UpdateFunctionCode</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li><li class="listitem"><p><a href="https://docs.rs/releases/search?query=aws-sdk" rel="noopener noreferrer" target="_blank"><span>UpdateFunctionConfiguration</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a></p></li></ul></div>
                </li></ul></div>
        </dd>
    </dl></div>
        </dd>
    <dt>SAP ABAP</dt><dd tab-id="sap-abap">
            <div class="variablelist">
     
<dl>
        <dt><b><span class="term">SDK for SAP ABAP</span></b></dt>
        <dd>
            <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>
                    There's more on GitHub. Find the complete example and learn how to set up and run in the
                    <a href="https://github.com/awsdocs/aws-doc-sdk-examples/tree/main/sap-abap/services/lambda#code-examples" rel="noopener noreferrer" target="_blank"><span>AWS Code Examples Repository</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a>.
                </p></div></div>
             
                <p></p>
                
                <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="sap-abap ">
    TRY.
        "Create an AWS Identity and Access Management (IAM) role that grants AWS Lambda permission to write to logs."
        DATA(lv_policy_document) = `<span>{</span>` &amp;&amp;
            `"Version":"2012-10-17",` &amp;&amp;
                  `"Statement": [` &amp;&amp;
                    `<span>{</span>` &amp;&amp;
                      `"Effect": "Allow",` &amp;&amp;
                      `"Action": [` &amp;&amp;
                        `"sts:AssumeRole"` &amp;&amp;
                      `],` &amp;&amp;
                      `"Principal": <span>{</span>` &amp;&amp;
                        `"Service": [` &amp;&amp;
                          `"lambda.amazonaws.com"` &amp;&amp;
                        `]` &amp;&amp;
                      `}` &amp;&amp;
                    `}` &amp;&amp;
                  `]` &amp;&amp;
                `}`.
        TRY.
            DATA(lo_create_role_output) =  lo_iam-&gt;createrole(
                    iv_rolename = iv_role_name
                    iv_assumerolepolicydocument = lv_policy_document
                    iv_description = 'Grant lambda permission to write to logs'
                ).
            MESSAGE 'IAM role created.' TYPE 'I'.
            WAIT UP TO 10 SECONDS.            " Make sure that the IAM role is ready for use. "
          CATCH /aws1/cx_iamentityalrdyexex.
            MESSAGE 'IAM role already exists.' TYPE 'E'.
          CATCH /aws1/cx_iaminvalidinputex.
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'.
          CATCH /aws1/cx_iammalformedplydocex.
            MESSAGE 'Policy document in the request is malformed.' TYPE 'E'.
        ENDTRY.

        TRY.
            lo_iam-&gt;attachrolepolicy(
                iv_rolename  = iv_role_name
                iv_policyarn = 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
            ).
            MESSAGE 'Attached policy to the IAM role.' TYPE 'I'.
          CATCH /aws1/cx_iaminvalidinputex.
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'.
          CATCH /aws1/cx_iamnosuchentityex.
            MESSAGE 'The requested resource entity does not exist.' TYPE 'E'.
          CATCH /aws1/cx_iamplynotattachableex.
            MESSAGE 'Service role policies can only be attached to the service-linked role for their service.' TYPE 'E'.
          CATCH /aws1/cx_iamunmodableentityex.
            MESSAGE 'Service that depends on the service-linked role is not modifiable.' TYPE 'E'.
        ENDTRY.

        " Create a Lambda function and upload handler code. "
        " Lambda function performs 'increment' action on a number. "
        TRY.
            lo_lmd-&gt;createfunction(
                 iv_functionname = iv_function_name
                 iv_runtime = `python3.9`
                 iv_role = lo_create_role_output-&gt;get_role( )-&gt;get_arn( )
                 iv_handler = iv_handler
                 io_code = io_initial_zip_file
                 iv_description = 'AWS Lambda code example'
             ).
            MESSAGE 'Lambda function created.' TYPE 'I'.
          CATCH /aws1/cx_lmdcodestorageexcdex.
            MESSAGE 'Maximum total code size per account exceeded.' TYPE 'E'.
          CATCH /aws1/cx_lmdinvparamvalueex.
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'.
          CATCH /aws1/cx_lmdresourcenotfoundex.
            MESSAGE 'The requested resource does not exist.' TYPE 'E'.
        ENDTRY.

        " Verify the function is in Active state "
        WHILE lo_lmd-&gt;getfunction( iv_functionname = iv_function_name )-&gt;get_configuration( )-&gt;ask_state( ) &lt;&gt; 'Active'.
          IF sy-index = 10.
            EXIT.               " Maximum 10 seconds. "
          ENDIF.
          WAIT UP TO 1 SECONDS.
        ENDWHILE.

        "Invoke the function with a single parameter and get results."
        TRY.
            DATA(lv_json) = /aws1/cl_rt_util=&gt;string_to_xstring(
              `<span>{</span>`  &amp;&amp;
                `"action": "increment",`  &amp;&amp;
                `"number": 10` &amp;&amp;
              `}`
            ).
            DATA(lo_initial_invoke_output) =  lo_lmd-&gt;invoke(
                       iv_functionname = iv_function_name
                       iv_payload = lv_json
                   ).
            ov_initial_invoke_payload = lo_initial_invoke_output-&gt;get_payload( ).           " ov_initial_invoke_payload is returned for testing purposes. "
            DATA(lo_writer_json) = cl_sxml_string_writer=&gt;create( type = if_sxml=&gt;co_xt_json ).
            CALL TRANSFORMATION id SOURCE XML ov_initial_invoke_payload RESULT XML lo_writer_json.
            DATA(lv_result) = cl_abap_codepage=&gt;convert_from( lo_writer_json-&gt;get_output( ) ).
            MESSAGE 'Lambda function invoked.' TYPE 'I'.
          CATCH /aws1/cx_lmdinvparamvalueex.
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'.
          CATCH /aws1/cx_lmdinvrequestcontex.
            MESSAGE 'Unable to parse request body as JSON.' TYPE 'E'.
          CATCH /aws1/cx_lmdresourcenotfoundex.
            MESSAGE 'The requested resource does not exist.' TYPE 'E'.
          CATCH /aws1/cx_lmdunsuppedmediatyp00.
            MESSAGE 'Invoke request body does not have JSON as its content type.' TYPE 'E'.
        ENDTRY.

        " Update the function code and configure its Lambda environment with an environment variable. "
        " Lambda function is updated to perform 'decrement' action also. "
        TRY.
            lo_lmd-&gt;updatefunctioncode(
                  iv_functionname = iv_function_name
                  iv_zipfile = io_updated_zip_file
              ).
            WAIT UP TO 10 SECONDS.            " Make sure that the update is completed. "
            MESSAGE 'Lambda function code updated.' TYPE 'I'.
          CATCH /aws1/cx_lmdcodestorageexcdex.
            MESSAGE 'Maximum total code size per account exceeded.' TYPE 'E'.
          CATCH /aws1/cx_lmdinvparamvalueex.
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'.
          CATCH /aws1/cx_lmdresourcenotfoundex.
            MESSAGE 'The requested resource does not exist.' TYPE 'E'.
        ENDTRY.

        TRY.
            DATA lt_variables TYPE /aws1/cl_lmdenvironmentvaria00=&gt;tt_environmentvariables.
            DATA ls_variable LIKE LINE OF lt_variables.
            ls_variable-key = 'LOG_LEVEL'.
            ls_variable-value = NEW /aws1/cl_lmdenvironmentvaria00( iv_value = 'info' ).
            INSERT ls_variable INTO TABLE lt_variables.

            lo_lmd-&gt;updatefunctionconfiguration(
                  iv_functionname = iv_function_name
                  io_environment = NEW /aws1/cl_lmdenvironment( it_variables = lt_variables )
              ).
            WAIT UP TO 10 SECONDS.            " Make sure that the update is completed. "
            MESSAGE 'Lambda function configuration/settings updated.' TYPE 'I'.
          CATCH /aws1/cx_lmdinvparamvalueex.
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'.
          CATCH /aws1/cx_lmdresourceconflictex.
            MESSAGE 'Resource already exists or another operation is in progress.' TYPE 'E'.
          CATCH /aws1/cx_lmdresourcenotfoundex.
            MESSAGE 'The requested resource does not exist.' TYPE 'E'.
        ENDTRY.

        "Invoke the function with new parameters and get results. Display the execution log that's returned from the invocation."
        TRY.
            lv_json = /aws1/cl_rt_util=&gt;string_to_xstring(
              `<span>{</span>`  &amp;&amp;
                `"action": "decrement",`  &amp;&amp;
                `"number": 10` &amp;&amp;
              `}`
            ).
            DATA(lo_updated_invoke_output) =  lo_lmd-&gt;invoke(
                       iv_functionname = iv_function_name
                       iv_payload = lv_json
                   ).
            ov_updated_invoke_payload = lo_updated_invoke_output-&gt;get_payload( ).           " ov_updated_invoke_payload is returned for testing purposes. "
            lo_writer_json = cl_sxml_string_writer=&gt;create( type = if_sxml=&gt;co_xt_json ).
            CALL TRANSFORMATION id SOURCE XML ov_updated_invoke_payload RESULT XML lo_writer_json.
            lv_result = cl_abap_codepage=&gt;convert_from( lo_writer_json-&gt;get_output( ) ).
            MESSAGE 'Lambda function invoked.' TYPE 'I'.
          CATCH /aws1/cx_lmdinvparamvalueex.
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'.
          CATCH /aws1/cx_lmdinvrequestcontex.
            MESSAGE 'Unable to parse request body as JSON.' TYPE 'E'.
          CATCH /aws1/cx_lmdresourcenotfoundex.
            MESSAGE 'The requested resource does not exist.' TYPE 'E'.
          CATCH /aws1/cx_lmdunsuppedmediatyp00.
            MESSAGE 'Invoke request body does not have JSON as its content type.' TYPE 'E'.
        ENDTRY.

        " List the functions for your account. "
        TRY.
            DATA(lo_list_output) = lo_lmd-&gt;listfunctions( ).
            DATA(lt_functions) = lo_list_output-&gt;get_functions( ).
            MESSAGE 'Retrieved list of Lambda functions.' TYPE 'I'.
          CATCH /aws1/cx_lmdinvparamvalueex.
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'.
        ENDTRY.

        " Delete the Lambda function. "
        TRY.
            lo_lmd-&gt;deletefunction( iv_functionname = iv_function_name ).
            MESSAGE 'Lambda function deleted.' TYPE 'I'.
          CATCH /aws1/cx_lmdinvparamvalueex.
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'.
          CATCH /aws1/cx_lmdresourcenotfoundex.
            MESSAGE 'The requested resource does not exist.' TYPE 'E'.
        ENDTRY.

        " Detach role policy. "
        TRY.
            lo_iam-&gt;detachrolepolicy(
                iv_rolename  = iv_role_name
                iv_policyarn = 'arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
            ).
            MESSAGE 'Detached policy from the IAM role.' TYPE 'I'.
          CATCH /aws1/cx_iaminvalidinputex.
            MESSAGE 'The request contains a non-valid parameter.' TYPE 'E'.
          CATCH /aws1/cx_iamnosuchentityex.
            MESSAGE 'The requested resource entity does not exist.' TYPE 'E'.
          CATCH /aws1/cx_iamplynotattachableex.
            MESSAGE 'Service role policies can only be attached to the service-linked role for their service.' TYPE 'E'.
          CATCH /aws1/cx_iamunmodableentityex.
            MESSAGE 'Service that depends on the service-linked role is not modifiable.' TYPE 'E'.
        ENDTRY.

        " Delete the IAM role. "
        TRY.
            lo_iam-&gt;deleterole( iv_rolename = iv_role_name ).
            MESSAGE 'IAM role deleted.' TYPE 'I'.
          CATCH /aws1/cx_iamnosuchentityex.
            MESSAGE 'The requested resource entity does not exist.' TYPE 'E'.
          CATCH /aws1/cx_iamunmodableentityex.
            MESSAGE 'Service that depends on the service-linked role is not modifiable.' TYPE 'E'.
        ENDTRY.

      CATCH /aws1/cx_rt_service_generic INTO lo_exception.
        DATA(lv_error) = lo_exception-&gt;get_longtext( ).
        MESSAGE lv_error TYPE 'E'.
    ENDTRY.

</code></pre>
             
            <div class="itemizedlist">
                 
            <ul class="itemizedlist"><li class="listitem">
                    <p>For API details, see the following topics in <em>AWS SDK for SAP ABAP API reference</em>.</p>
                    <div class="itemizedlist">
                         
                         
                         
                         
                         
                         
                         
                    <ul class="itemizedlist"><li class="listitem"><p><a href="https://docs.aws.amazon.com/sdk-for-sap-abap/v1/api/latest/index.html">CreateFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/sdk-for-sap-abap/v1/api/latest/index.html">DeleteFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/sdk-for-sap-abap/v1/api/latest/index.html">GetFunction</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/sdk-for-sap-abap/v1/api/latest/index.html">Invoke</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/sdk-for-sap-abap/v1/api/latest/index.html">ListFunctions</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/sdk-for-sap-abap/v1/api/latest/index.html">UpdateFunctionCode</a></p></li><li class="listitem"><p><a href="https://docs.aws.amazon.com/sdk-for-sap-abap/v1/api/latest/index.html">UpdateFunctionConfiguration</a></p></li></ul></div>
                </li></ul></div>
        </dd>
    </dl></div>
        </dd>
</dl></awsdocs-tabs><p>For a complete list of AWS SDK developer guides and code examples, see
    <a href="./sdk-general-information-section.html">Using Lambda with an AWS SDK</a>.
    This topic also includes information about getting started and details about previous SDK versions.</p><awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Warning" /> <strong>Javascript is disabled or is unavailable in your browser.</strong></p><p>To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Document Conventions</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./service_code_examples_scenarios.html">Scenarios</div><div id="next" class="next-link" accesskey="n" href="./service_code_examples_serverless_examples.html">Serverless examples</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">Did this page help you? - Yes</div><div class="content"><p>Thanks for letting us know we're doing a good job!</p><p>If you've got a moment, please tell us what we did right so we can do more of it.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Lambda&amp;topic_url=https://docs.aws.amazon.com/en_us/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">Did this page help you? - No</div><div class="content"><p>Thanks for letting us know this page needs work. We're sorry we let you down.</p><p>If you've got a moment, please tell us how we can make the documentation better.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Lambda&amp;topic_url=https://docs.aws.amazon.com/en_us/lambda/latest/dg/example_lambda_Scenario_GettingStartedFunctions_section.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>