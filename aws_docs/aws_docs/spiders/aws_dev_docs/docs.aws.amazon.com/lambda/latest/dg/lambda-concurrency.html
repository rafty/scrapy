<!DOCTYPE html>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Lambda function scaling - AWS Lambda</title><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="assets_root" content="/assets" /><meta name="target_state" content="lambda-concurrency" /><meta name="default_state" content="lambda-concurrency" /><link rel="icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="shortcut icon" type="image/ico" href="/assets/images/favicon.ico" /><link rel="canonical" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-concurrency.html" /><meta name="description" content="Concurrency is the number of in-flight requests your AWS Lambda function is handling at the same time. For each concurrent request, Lambda provisions a separate instance of your execution environment. As your functions receive more requests, Lambda automatically handles scaling the number of execution environments until you reach your account's concurrency limit. By default, Lambda provides your account with a total concurrency limit of 1,000 across all functions in a region. To support your specific account needs, you can" /><meta name="deployment_region" content="IAD" /><meta name="product" content="AWS Lambda" /><meta name="guide" content="Developer Guide" /><meta name="abstract" content="" /><meta name="guide-locale" content="en_us" /><meta name="tocs" content="toc-contents.json" /><link rel="canonical" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-concurrency.html" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/lambda/latest/dg/lambda-concurrency.html" hreflang="id-id" /><link rel="alternative" href="https://docs.aws.amazon.com/id_id/lambda/latest/dg/lambda-concurrency.html" hreflang="id" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/lambda/latest/dg/lambda-concurrency.html" hreflang="de-de" /><link rel="alternative" href="https://docs.aws.amazon.com/de_de/lambda/latest/dg/lambda-concurrency.html" hreflang="de" /><link rel="alternative" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-concurrency.html" hreflang="en-us" /><link rel="alternative" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-concurrency.html" hreflang="en" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/lambda/latest/dg/lambda-concurrency.html" hreflang="es-es" /><link rel="alternative" href="https://docs.aws.amazon.com/es_es/lambda/latest/dg/lambda-concurrency.html" hreflang="es" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/lambda/latest/dg/lambda-concurrency.html" hreflang="fr-fr" /><link rel="alternative" href="https://docs.aws.amazon.com/fr_fr/lambda/latest/dg/lambda-concurrency.html" hreflang="fr" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/lambda/latest/dg/lambda-concurrency.html" hreflang="it-it" /><link rel="alternative" href="https://docs.aws.amazon.com/it_it/lambda/latest/dg/lambda-concurrency.html" hreflang="it" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-concurrency.html" hreflang="ja-jp" /><link rel="alternative" href="https://docs.aws.amazon.com/ja_jp/lambda/latest/dg/lambda-concurrency.html" hreflang="ja" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/lambda-concurrency.html" hreflang="ko-kr" /><link rel="alternative" href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/lambda-concurrency.html" hreflang="ko" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/lambda/latest/dg/lambda-concurrency.html" hreflang="pt-br" /><link rel="alternative" href="https://docs.aws.amazon.com/pt_br/lambda/latest/dg/lambda-concurrency.html" hreflang="pt" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/lambda-concurrency.html" hreflang="zh-cn" /><link rel="alternative" href="https://docs.aws.amazon.com/zh_tw/lambda/latest/dg/lambda-concurrency.html" hreflang="zh-tw" /><link rel="alternative" href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-concurrency.html" hreflang="x-default" /><meta name="feedback-item" content="Lambda" /><meta name="this_doc_product" content="AWS Lambda" /><meta name="this_doc_guide" content="Developer Guide" /><script defer="" src="/assets/r/vendor4.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor3.js?version=2021.12.02"></script><script defer="" src="/assets/r/vendor1.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-common.js?version=2021.12.02"></script><script defer="" src="/assets/r/awsdocs-doc-page.js?version=2021.12.02"></script><link href="/assets/r/vendor4.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-common.css?version=2021.12.02" rel="stylesheet" /><link href="/assets/r/awsdocs-doc-page.css?version=2021.12.02" rel="stylesheet" /><script async="" id="awsc-panorama-bundle" type="text/javascript" src="https://prod.pa.cdn.uis.awsstatic.com/panorama-nav-init.js" data-config="{'appEntity':'aws-documentation','region':'us-east-1','service':'lambda'}"></script><meta id="panorama-serviceSubSection" value="Developer Guide" /><meta id="panorama-serviceConsolePage" value="Lambda function scaling" /></head><body class="awsdocs awsui"><div class="awsdocs-container"><awsdocs-header></awsdocs-header><awsui-app-layout id="app-layout" class="awsui-util-no-gutters" ng-controller="ContentController as $ctrl" header-selector="awsdocs-header" navigation-hide="false" navigation-width="$ctrl.navWidth" navigation-open="$ctrl.navOpen" navigation-change="$ctrl.onNavChange($event)" tools-hide="$ctrl.hideTools" tools-width="$ctrl.toolsWidth" tools-open="$ctrl.toolsOpen" tools-change="$ctrl.onToolsChange($event)"><div id="guide-toc" dom-region="navigation"><awsdocs-toc></awsdocs-toc></div><div id="main-column" dom-region="content" tabindex="-1"><awsdocs-view class="awsdocs-view"><div id="awsdocs-content"><head><title>Lambda function scaling - AWS Lambda</title><meta name="pdf" content="/pdfs/lambda/latest/dg/lambda-dg.pdf#lambda-concurrency" /><meta name="rss" content="lambda-updates.rss" /><meta name="forums" content="http://forums.aws.amazon.com/forum.jspa?forumID=186" /><meta name="feedback" content="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Lambda&amp;topic_url=http://docs.aws.amazon.com/en_us/lambda/latest/dg/lambda-concurrency.html" /><meta name="feedback-yes" content="feedbackyes.html?topic_url=http://docs.aws.amazon.com/en_us/lambda/latest/dg/lambda-concurrency.html" /><meta name="feedback-no" content="feedbackno.html?topic_url=http://docs.aws.amazon.com/en_us/lambda/latest/dg/lambda-concurrency.html" /><meta name="keywords" content="Lambda,AWS Lambda,serverless,serverless applications,cloud computing,configure Lambda concurrency,configure Lambda networking,configure Lambda database access,configure Lambda code signing,Lambda concurrency,Lambda function scaling,function scaling,calculate Lambda concurrency,Lambda concurrency quotas,Lambda concurrency metrics" /><script type="application/ld+json">
{
    "@context" : "https://schema.org",
    "@type" : "BreadcrumbList",
    "itemListElement" : [
      {
        "@type" : "ListItem",
        "position" : 1,
        "name" : "AWS",
        "item" : "https://aws.amazon.com"
      },
      {
        "@type" : "ListItem",
        "position" : 2,
        "name" : "AWS Lambda",
        "item" : "https://docs.aws.amazon.com/lambda/index.html"
      },
      {
        "@type" : "ListItem",
        "position" : 3,
        "name" : "Developer Guide",
        "item" : "https://docs.aws.amazon.com/lambda/latest/dg"
      },
      {
        "@type" : "ListItem",
        "position" : 4,
        "name" : "Managing AWS Lambda functions",
        "item" : "https://docs.aws.amazon.com/lambda/latest/dg/lambda-managing.html"
      },
      {
        "@type" : "ListItem",
        "position" : 5,
        "name" : "Lambda function scaling",
        "item" : "https://docs.aws.amazon.com/lambda/latest/dg/lambda-managing.html"
      }
    ]
}
</script></head><body><div id="main"><div style="display: none"><a href="/pdfs/lambda/latest/dg/lambda-dg.pdf#lambda-concurrency" target="_blank" rel="noopener noreferrer" title="Open PDF"></a></div><div id="breadcrumbs" class="breadcrumb"><a href="https://aws.amazon.com">AWS</a><a href="/index.html">Documentation</a><a href="/lambda/index.html">AWS Lambda</a><a href="welcome.html">Developer Guide</a></div><div id="page-toc-src"><a href="#understanding-concurrency">Understanding and visualizing concurrency</a><a href="#calculating-concurrency">How to calculate concurrency</a><a href="#concurrency-vs-requests-per-second">Concurrency vs. requests per second</a><a href="#reserved-and-provisioned">Reserved concurrency and provisioned concurrency</a><a href="#concurrency-quotas">Concurrency quotas</a></div><div id="main-content" class="awsui-util-container"><div id="main-col-body"><awsdocs-language-banner data-service="$ctrl.pageService"></awsdocs-language-banner><h1 class="topictitle" id="lambda-concurrency">Lambda function scaling</h1><div class="awsdocs-page-header-container"><awsdocs-page-header></awsdocs-page-header><awsdocs-filter-selector id="awsdocs-filter-selector"></awsdocs-filter-selector></div><p><b>Concurrency</b> is the number of in-flight requests your AWS Lambda
    function is handling at the same time. For each concurrent request, Lambda provisions a separate
    instance of your execution environment. As your functions receive more requests, Lambda automatically
    handles scaling the number of execution environments until you reach your account's concurrency
    limit. By default, Lambda provides your account with a total concurrency limit of 1,000 across all
    functions in a region. To support your specific account needs, you can
    <a href="https://aws.amazon.com/premiumsupport/knowledge-center/lambda-concurrency-limit-increase/" rel="noopener noreferrer" target="_blank"><span>
    request a quota increase</span><awsui-icon class="awsdocs-link-icon" name="external"></awsui-icon></a> and configure function-level concurrency controls so that your
    critical functions don't experience throttling.</p><p>This topic explains concurrency and function scaling in Lambda. By the end of this topic, you'll be able to
    understand how to calculate concurrency, visualize the two main concurrency control options (reserved and
    provisioned), estimate appropriate concurrency control settings, and view metrics for further optimization.</p><div class="highlights"><h6>Sections</h6><ul><li><a href="#understanding-concurrency">Understanding and visualizing concurrency</a></li><li><a href="#calculating-concurrency">How to calculate concurrency</a></li><li><a href="#concurrency-vs-requests-per-second">Concurrency vs. requests per second</a></li><li><a href="#reserved-and-provisioned">Reserved concurrency and provisioned concurrency</a></li><li><a href="#concurrency-quotas">Concurrency quotas</a></li><li><a href="./configuration-concurrency.html">Configuring reserved concurrency</a></li><li><a href="./provisioned-concurrency.html">Configuring provisioned concurrency</a></li><li><a href="./burst-concurrency.html">Burst concurrency</a></li><li><a href="./monitoring-concurrency.html">Monitoring concurrency</a></li></ul></div>
    <h2 id="understanding-concurrency">Understanding and visualizing concurrency</h2>
    <p>Lambda invokes your function in a secure and isolated <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtime-environment.html">execution environment</a>. To handle a
      request, Lambda must first initialize an execution environment (the <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtime-environment.html#runtimes-lifecycle-ib">Init phase</a>),
      before using it to invoke your function (the <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtime-environment.html#runtimes-lifecycle-invoke">Invoke phase</a>):</p>
    <div class="mediaobject">
       
        <img src="/images/lambda/latest/dg/images/concurrency-1-environment.png" class="aws-docs-img-whiteBg aws-docs-img-padding" alt="&#xA;        Typical lifecycle of an execution environment, showing Init and Invoke phases.&#xA;      " style="max-width:100%" />
       
       
    </div>
    <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>Actual Init and Invoke durations can vary depending on many factors, such as the runtime you choose
      and the Lambda function code. The previous diagram isn't meant to represent the exact proportions of Init and
      Invoke phase durations.</p></div></div>
    <p>The previous diagram uses a rectangle to represent a single execution environment. When your function
      receives its very first request (represented by the yellow circle with label <code class="code">1</code>), Lambda creates
      a new execution environment and runs the code outside your main handler during the Init phase. Then, Lambda
      runs your function's main handler code during the Invoke phase. During this entire process, this execution
      environment is busy and cannot process other requests.</p>
    <p>When Lambda finishes processing the first request, this execution environment can then process additional
      requests for the same function. For subsequent requests, Lambda doesn't need to re-initialize the environment.</p>
    <div class="mediaobject">
       
        <img src="/images/lambda/latest/dg/images/concurrency-2-two-requests.png" class="aws-docs-img-whiteBg aws-docs-img-padding" alt="&#xA;        An execution environment handling two requests in succession.&#xA;      " style="max-width:100%" />
       
       
    </div>
    <p>In the previous diagram, Lambda reuses the execution environment to handle the second request
      (represented by the yellow circle with label <code class="code">2</code>).</p>
    <p>So far, we've focused on just a single instance of your execution environment (i.e. a concurrency of 1).
      In practice, Lambda may need to provision multiple execution environment instances in parallel to handle all
      incoming requests. When your function receives a new request, one of two things can happen:</p>
    <div class="itemizedlist">
       
       
    <ul class="itemizedlist"><li class="listitem">
        <p>If a pre-initialized execution environment instance is available, Lambda uses it to process the request.</p>
      </li><li class="listitem">
        <p>Otherwise, Lambda creates a new execution environment instance to process the request.</p>
      </li></ul></div>
    <p>For example, let's explore what happens when your function receives 10 requests:</p>
    <div class="mediaobject">
       
        <img src="/images/lambda/latest/dg/images/concurrency-3-ten-requests.png" class="aws-docs-img-whiteBg aws-docs-img-padding" alt="&#xA;        A Lambda function handling 10 requests. It must provision multiple environments to handle all requests.&#xA;      " style="max-width:100%" />
       
       
    </div>
    <p>In the previous diagram, each horizontal plane represents a single execution environment instance
      (labeled from <code class="code">A</code> through <code class="code">F</code>. Here's how Lambda handles each request:</p>
    <div class="table-container"><div class="table-contents"><table id="w917aac35c17b9c27"><thead><tr><th class="table-header" colspan="100"><div class="title">Lambda behavior for requests 1 through 10</div></th></tr>
          <tr>
            <th>Request</th>
            <th>Lambda behavior</th>
            <th>Reasoning</th>
          </tr>
        </thead>
          <tr>
            <td tabindex="-1">
              <p>1</p>
            </td>
            <td tabindex="-1">
              <p>Provisions new environment <b>A</b></p>
            </td>
            <td tabindex="-1">
              <p>This is the first request; no execution environment instances available</p>
            </td>
          </tr>
          <tr>
            <td tabindex="-1">
              <p>2</p>
            </td>
            <td tabindex="-1">
              <p>Provisions new environment <b>B</b></p>
            </td>
            <td tabindex="-1">
              <p>Existing execution environment instance <b>A</b> is busy</p>
            </td>
          </tr>
          <tr>
            <td tabindex="-1">
              <p>3</p>
            </td>
            <td tabindex="-1">
              <p>Provisions new environment <b>C</b></p>
            </td>
            <td tabindex="-1">
              <p>Existing execution environment instances <b>A</b> and 
                <b>B</b> are both busy</p>
            </td>
          </tr>
          <tr>
            <td tabindex="-1">
              <p>4</p>
            </td>
            <td tabindex="-1">
              <p>Provisions new environment <b>D</b></p>
            </td>
            <td tabindex="-1">
              <p>Existing execution environment instances <b>A</b>,  
                <b>B</b>, and
                <b>C</b> are all busy</p>
            </td>
          </tr>
          <tr>
            <td tabindex="-1">
              <p>5</p>
            </td>
            <td tabindex="-1">
              <p>Provisions new environment <b>E</b></p>
            </td>
            <td tabindex="-1">
              <p>Existing execution environment instances <b>A</b>,  
                <b>B</b>,
                <b>C</b>, and
                <b>D</b> are all busy</p>
            </td>
          </tr>
          <tr>
            <td tabindex="-1">
              <p>6</p>
            </td>
            <td tabindex="-1">
              <p>Reuses environment <b>A</b></p>
            </td>
            <td tabindex="-1">
              <p>Execution environment instance <b>A</b> has finished
                processing request <b>1</b> and is now available</p>
            </td>
          </tr>
          <tr>
            <td tabindex="-1">
              <p>7</p>
            </td>
            <td tabindex="-1">
              <p>Reuses environment <b>B</b></p>
            </td>
            <td tabindex="-1">
              <p>Execution environment instance <b>B</b> has finished
                processing request <b>2</b> and is now available</p>
            </td>
          </tr>
          <tr>
            <td tabindex="-1">
              <p>8</p>
            </td>
            <td tabindex="-1">
              <p>Reuses environment <b>C</b></p>
            </td>
            <td tabindex="-1">
              <p>Execution environment instance <b>C</b> has finished
                processing request <b>3</b> and is now available</p>
            </td>
          </tr>
          <tr>
            <td tabindex="-1">
              <p>9</p>
            </td>
            <td tabindex="-1">
              <p>Provisions new environment <b>F</b></p>
            </td>
            <td tabindex="-1">
              <p>Existing execution environment instances <b>A</b>,  
                <b>B</b>,
                <b>C</b>,
                <b>D</b>, and
                <b>E</b> are all busy</p>
            </td>
          </tr>
          <tr>
            <td tabindex="-1">
              <p>10</p>
            </td>
            <td tabindex="-1">
              <p>Reuses environment <b>D</b></p>
            </td>
            <td tabindex="-1">
              <p>Execution environment instance <b>D</b> has finished
                processing request <b>4</b> and is now available</p>
            </td>
          </tr>
        </table></div></div>
    <p>As your function receives more concurrent requests, Lambda scales up the number of execution
      environment instances in response. The following animation tracks the number of concurrent
      requests over time:</p>
    <div class="mediaobject">
       
        <img src="/images/lambda/latest/dg/images/concurrency-4-animation.gif" class="aws-docs-img-whiteBg aws-docs-img-padding" alt="&#xA;        An animation illustrating concurrent requests over time.&#xA;      " style="max-width:100%" />
       
       
    </div>
    <p>By freezing the previous animation at six distinct points in time, we get the following
      diagram:</p>
    <div class="mediaobject">
       
        <img src="/images/lambda/latest/dg/images/concurrency-5-animation-summary.png" class="aws-docs-img-whiteBg aws-docs-img-padding" alt="&#xA;        Function concurrency at six distinct points in time.&#xA;      " style="max-width:100%" />
       
       
    </div>
    <p>In the previous diagram, we can draw a vertical line at any point in time and count the
      number of environments that intersect this line. This gives us the number of concurrent requests
      at that point in time. For example, at time <code class="code">t1</code>, there are 3 active environments serving
      3 concurrent requests. The maximum number of concurrent requests in this simulation occurs at
      time <code class="code">t4</code>, when there are 6 active environments serving 6 concurrent requests.</p>
    <p>To summarize, your function's concurrency is the number of concurrent requests that it's handling
      at the same time. In response to an increase in your function's concurrency, Lambda provisions more
      execution environment instances to meet request demand.</p>
   
    <h2 id="calculating-concurrency">How to calculate concurrency</h2>
    <p>In general, concurrency of a system is the ability to process more than one task simultaneously.
      In Lambda, concurrency is the number of in-flight requests that your function is handling at the same
      time. A quick and practical way of measuring concurrency of a Lambda function is to use the following
      formula:</p>
    <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">Concurrency = (average requests per second) * (average request duration in seconds)</code></pre>
    <p><b>Concurrency differs from requests per second.</b> For example,
      suppose your function receives 100 requests per second on average. If the average request duration
      is 1 second, then it's true that the concurrency is also 100:</p>
    <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">Concurrency = (100 requests/second) * (1 second/request) = 100</code></pre>
    <p>However, if the average request duration is 500 ms, the concurrency is 50:</p>
    <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">Concurrency = (100 requests/second) * (0.5 second/request) = 50</code></pre>
    <p>What does a concurrency of 50 mean in practice? If the average request duration is 500 ms, you
      can think of an instance of your function as being able to handle 2 requests per second. Then, it
      takes 50 instances of your function to handle a load of 100 requests per second. A concurrency of
      50 means that Lambda must provision 50 execution environment instances to efficiently handle this
      workload without any throttling. Here's how to express this in equation form:</p>
    <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">Concurrency = (100 requests/second) / (2 requests/second) = 50</code></pre>
    <p>If your function receives double the number of requests (200 requests per second), but only
      requires half the time to process each request (250 ms), the concurrency is still 50:</p>
    <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">Concurrency = (200 requests/second) * (0.25 second/request) = 50</code></pre>
    <div class="collapsible" data-expand-section="_collapse_all_"><awsui-expandable-section variant="container" header="Test your understanding of concurrency" id="concurrency-test" expanded="false"><p>Suppose you have a function that takes, on average, 200 ms to run. During peak load, you
          observe 5,000 requests per second. What is the concurrency of your function during
          peak load?
        </p><div class="collapsible" data-expand-section="_collapse_all_"><awsui-expandable-section variant="container" header="Answer" id="concurrency-test-answer" expanded="false"><p>The average function duration is 200 ms, or 0.2 seconds. Using the concurrency formula,
              you can plug in the numbers to get a concurrency of 1000:</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">Concurrency = (5,000 requests/second) * (0.2 seconds/request) = 1,000</code></pre><p>Alternatively, an average function duration of 200 ms means that your function can process
              5 requests per second. To handle the 5,000 request per second workload, you need 1,000
              execution environment instances. Thus, the concurrency is 1,000:</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">Concurrency = (5,000 requests/second) / (5 requests/second) = 1,000</code></pre></awsui-expandable-section></div></awsui-expandable-section></div>
   
    <h2 id="concurrency-vs-requests-per-second">Concurrency vs. requests per second</h2>
    <p>As mentioned in the previous section, concurrency differs from requests per second. This is an
      especially important distinction to make when working with functions that have an average request
      duration of less than 100 ms.</p>
    <p>In general, each instance of your execution environment can handle at most 10 requests per
      second. This limit applies to synchronous on-demand functions, as well as functions that use
      provisioned concurrency. In you're unfamiliar with this limit, you may be confused as to why
      such functions could experience throttling in certain scenarios.</p>
    <p>For example, consider a function with an average request duration of 50 ms. At 200 requests
      per second, here's the concurrency of this function:</p>
    <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">Concurrency = (200 requests/second) * (0.05 second/request) = 10</code></pre>
    <p>Based on this result, you might expect that you only need 10 execution environment
      instances to handle this load. However, each execution environment can handle only 10
      executions per second. This means that with 10 execution environments, you can only handle
      100 requests per second out of the 200 total requests. This function experiences throttling.</p>
    <p>The lesson is that you need to consider both concurrency and requests per second when
      configuring concurrency settings for your functions. In this case, you need 20 execution
      environments for your function, even though it only has a concurrency of 10.</p>
    <div class="collapsible" data-expand-section="_collapse_all_"><awsui-expandable-section variant="container" header="Test your understanding of concurrency (sub-100 ms functions)" id="concurrency-test-2" expanded="false"><p>Suppose you have a function that takes, on average, 20 ms to run. During peak load, you
          observe 3,000 requests per second. What is the concurrency of your function during
          peak load?
        </p><div class="collapsible" data-expand-section="_collapse_all_"><awsui-expandable-section variant="container" header="Answer" id="concurrency-test-2-answer" expanded="false"><p>The average function duration is 20 ms, or 0.02 seconds. Using the concurrency formula,
              you can plug in the numbers to get a concurrency of 60:</p><pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">Concurrency = (3,000 requests/second) * (0.02 seconds/request) = 60</code></pre><p>However, each execution environment can handle only 10 requests per second. With 60
              execution environments, your function can handle a maximum of 600 requests per second. In
              order to fully accommodate the 3,000 requests, you'll need at least 300 execution
              environment instances.</p></awsui-expandable-section></div></awsui-expandable-section></div>
   
    <h2 id="reserved-and-provisioned">Reserved concurrency and provisioned concurrency</h2>
    <p>By default, your account has a concurrency limit of 1,000 across all functions in a region. Your
      functions share this pool of 1,000 concurrency on an on-demand basis. Your function experiences
      throttling (i.e. it starts to drop requests) if you run out of available concurrency.</p>
    <p>Some of your functions might be more critical than others. As a result, you might want to configure
      concurrency settings to ensure that critical functions get the concurrency they need. There are two types
      of concurrency controls available: reserved concurrency and provisioned concurrency.</p>
    <div class="itemizedlist">
       
       
    <ul class="itemizedlist"><li class="listitem">
        <p>Use <b>reserved concurrency</b> to reserve a portion of your account's
          concurrency for a function. This is useful if you don't want other functions taking up all the
          available unreserved concurrency.</p>
      </li><li class="listitem">
        <p>Use <b>provisioned concurrency</b> to pre-initialize a number of
          environment instances for a function. This is useful for reducing cold start latencies.</p>
      </li></ul></div>
     
      <h3 id="reserved-concurrency-concept">Reserved concurrency</h3>
      <p>If you want to guarantee that a certain amount of concurrency is available for your function at any
        time, use reserved concurrency.</p>
      <p>Reserved concurrency is the maximum number of concurrent instances you want to allocate to your
        function. When you dedicate reserved concurrency to a function, no other function can use that
        concurrency. In other words, setting reserved concurrency can impact the concurrency pool that's
        available to other functions. Functions that don't have reserved concurrency share the remaining pool
        of unreserved concurrency.</p>
      <p>Configuring reserved concurrency counts towards your overall account concurrency limit. There is
        no charge for configuring reserved concurrency for a function.</p>
      <p>To better understand reserved concurrency, consider the following diagram:</p>
      <div class="mediaobject">
         
          <img src="/images/lambda/latest/dg/images/concurrency-6-reserved-concurrency.png" class="aws-docs-img-whiteBg aws-docs-img-padding" alt="&#xA;          Function scaling behavior when the user configures reserved concurrency on critical functions.&#xA;        " style="max-width:100%" />
         
         
      </div>
      <p>In this diagram, your account concurrency limit for all the functions in this region is at the default
        limit of 1,000. Suppose you have two critical functions, <code class="code">function-blue</code> and
        <code class="code">function-orange</code>, that routinely expect to get high invocation volumes. You decide to give 400
        units of reserved concurrency to <code class="code">function-blue</code>, and 400 units of reserved concurrency to
        <code class="code">function-orange</code>. In this example, all other functions in your account must share the remaining
        200 units of unreserved concurrency.</p>
      <p>The diagram has 5 points of interest:</p>
      <div class="itemizedlist">
         
         
         
         
         
      <ul class="itemizedlist"><li class="listitem">
          <p>At <code class="code">t1</code>, both <code class="code">function-orange</code> and <code class="code">function-blue</code> begin receiving
            requests. Each function begins to use up their allocated portion of reserved concurrency units.</p>
        </li><li class="listitem">
          <p>At <code class="code">t2</code>, <code class="code">function-orange</code> and <code class="code">function-blue</code> are steadily receiving
            more requests. At the same time, you deploy some other Lambda functions, which begin receiving requests.
            You do not allocate reserved concurrency to these other functions. They begin using the remaining 200 units
            of unreserved concurrency.</p>
        </li><li class="listitem">
          <p>At <code class="code">t3</code>, <code class="code">function-orange</code> hits the max concurrency of 400. Although there is
            unused concurrency elsewhere in your account, <code class="code">function-orange</code> cannot access it. The red line
            indicates that <code class="code">function-orange</code> is experiencing throttling, and Lambda may drop requests.</p>
        </li><li class="listitem">
          <p>At <code class="code">t4</code>, <code class="code">function-orange</code> starts to receive fewer requests and is no longer
            throttling. However, your other functions experience a spike in traffic and begin throttling. Although
            there is unused concurrency elsewhere in your account, these other functions cannot access it. The red
            line indicates that your other functions are experiencing throttling.</p>
        </li><li class="listitem">
          <p>At <code class="code">t5</code>, other functions start to receive fewer requests and are no longer throttling.</p>
        </li></ul></div>
      <p>From this example, notice that reserving concurrency has the following effects:</p>
      <div class="itemizedlist">
         
         
         
      <ul class="itemizedlist"><li class="listitem">
          <p><b>Your function can scale independently of other functions in your account.</b>
            All of your account's functions in the same region that don't have reserved concurrency share the pool of
            unreserved concurrency. Without reserved concurrency, other functions can potentially use up all of your
            available concurrency. This prevents critical functions from scaling up if needed.</p>
        </li><li class="listitem">
          <p><b>Your function can't scale out of control.</b> Reserved concurrency puts a cap
            on your function's maximum concurrency. This means that your function can't use concurrency reserved for other
            functions, or concurrency from the unreserved pool. You can reserve concurrency to prevent your function from
            using all the available concurrency in your account, or from overloading downstream resources.</p>
        </li><li class="listitem">
          <p><b>You may not be able to use all of your account's available concurrency.</b>
            Reserving concurrency counts towards your account concurrency limit, but this also means that other functions
            cannot use that chunk of reserved concurrency. If your function doesn't use up all of the concurrency that you
            reserve for it, you're effectively wasting that concurrency. This isn't an issue unless other functions in
            your account could benefit from the wasted concurrency.</p>
        </li></ul></div>
      <p>To manage reserved concurrency settings for your functions, see <a href="./configuration-concurrency.html">Configuring reserved concurrency</a>.</p>
     
     
      <h3 id="provisioned-concurrency-concept">Provisioned concurrency</h3>
      <p>You use reserved concurrency to define the maximum number of execution environments reserved for a Lambda function.
        However, none of these environments come pre-initialized. As a result, your function invocations may take longer
        because Lambda must first initialize the new environment before being able to use it to invoke your function.
        When Lambda has to initialize a new environment in order to carry out an invocation, this is known as a cold start. 
        To mitigate cold starts, you can use provisioned concurrency.</p>
      <p>Provisioned concurrency is the number of pre-initialized execution environments you want to allocate to your
        function. If you set provisioned concurrency on a function, Lambda initializes that number of execution environments
        so that they are prepared to respond immediately to function requests.</p>
      <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>Using provisioned concurrency incurs additional charges to your account. If you're working with the
          Java 11 or Java 17 runtimes, you can also use Lambda SnapStart to mitigate cold start issues at no
          additional cost. SnapStart uses cached snapshots of your execution environment to significantly
          improve start-up performance. You cannot use both SnapStart and provisioned concurrency on the same
          function version. For more information about SnapStart features, limitations, and supported regions,
          see <a href="./snapstart.html">Improving startup performance with Lambda SnapStart</a>.</p></div></div>
      <p>When using provisioned concurrency, Lambda still recycles execution environments in the background. However, at
        any given time, Lambda always ensures that the number of pre-initialized environments is equal to the value of your
        function's provisioned concurrency setting. This behavior differs from reserved concurrency, where Lambda may
        completely terminate an environment after a period of inactivity. The following diagram illustrates this by
        comparing the lifecycle of a single execution environment when you configure your function using reserved
        concurrency compared to provisioned concurrency.</p>
      <div class="mediaobject">
         
          <img src="/images/lambda/latest/dg/images/concurrency-7-reserved-vs-provisioned.png" class="aws-docs-img-whiteBg aws-docs-img-padding" alt="&#xA;          How function environment behavior differs uder a reserved concurrency vs provisioned concurrency model.&#xA;        " style="max-width:100%" />
         
         
      </div>
      <p>The diagram has four points of interest:</p>
      <div class="table-container"><div class="table-contents"><table id="w917aac35c17c15c11c15"><thead>
            <tr>
              <th>Time</th>
              <th>Reserved concurrency</th>
              <th>Provisioned concurrency</th>
            </tr>
          </thead>
            <tr>
              <td tabindex="-1">
                <p>t1</p>
              </td>
              <td tabindex="-1">
                <p>Nothing happens.</p>
              </td>
              <td tabindex="-1">
                <p>Lambda pre-initializes an execution environment instance.</p>
              </td>
            </tr>
            <tr>
              <td tabindex="-1">
                <p>t2</p>
              </td>
              <td tabindex="-1">
                <p>Request 1 comes in. Lambda must initialize a new execution environment instance.</p>
              </td>
              <td tabindex="-1">
                <p>Request 1 comes in. Lambda uses the pre-initialized environment instance.</p>
              </td>
            </tr>
            <tr>
              <td tabindex="-1">
                <p>t3</p>
              </td>
              <td tabindex="-1">
                <p>After some inactivity, Lambda terminates the active environment instance.</p>
              </td>
              <td tabindex="-1">
                <p>Nothing happens.</p>
              </td>
            </tr>
            <tr>
              <td tabindex="-1">
                <p>t4</p>
              </td>
              <td tabindex="-1">
                <p>Request 2 comes in. Lambda must initialize a new execution environment instance.</p>
              </td>
              <td tabindex="-1">
                <p>Request 2 comes in. Lambda uses the pre-initialized environment instance.</p>
              </td>
            </tr>
          </table></div></div>
      <p>To better understand provisioned concurrency, consider the following diagram:</p>
      <div class="mediaobject">
         
          <img src="/images/lambda/latest/dg/images/concurrency-8-provisioned-concurrency.png" class="aws-docs-img-whiteBg aws-docs-img-padding" alt="&#xA;          Function scaling behavior when the user configures provisioned concurrency on a critical function.&#xA;        " style="max-width:100%" />
         
         
      </div>
      <p>In this diagram, you have an account concurrency limit of 1,000. You decide to give 400 units of provisioned
        concurrency to <code class="code">function-orange</code>. All functions in your account, <b>including</b>
        <code class="code">function-orange</code>, can use the remaining 600 units of unreserved concurrency.</p>
      <p>The diagram has 5 points of interest:</p>
      <div class="itemizedlist">
         
         
         
         
         
      <ul class="itemizedlist"><li class="listitem">
          <p>At <code class="code">t1</code>, <code class="code">function-orange</code> begins receiving requests. Since Lambda has pre-initialized
            400 execution environment instances, <code class="code">function-orange</code> is ready for immediate invocation.</p>
        </li><li class="listitem">
          <p>At <code class="code">t2</code>, <code class="code">function-orange</code> reaches 400 concurrent requests. As a result,
            <code class="code">function-orange</code> runs out of provisioned concurrency. However, since there's still unreserved
            concurrency available, Lambda can use this to handle additional requests to <code class="code">function-orange</code>
            (there's no throttling). Lambda must create new instances to serve these requests, and your function may
            experience cold start latencies.</p>
        </li><li class="listitem">
          <p>At <code class="code">t3</code>, <code class="code">function-orange</code> returns to 400 concurrent requests after a brief spike
            in traffic. Lambda is again able to handle all requests without cold start latencies.</p>
        </li><li class="listitem">
          <p>At <code class="code">t4</code>, functions in your account experience a burst in traffic. This burst can come from
            <code class="code">function-orange</code> or any other function in your account. Lambda uses unreserved concurrency to
            handle these requests.</p>
        </li><li class="listitem">
          <p>At <code class="code">t5</code>, functions in your account reach the maximum concurrency limit of 1,000, and
            experience throttling.</p>
        </li></ul></div>
      <p>The previous example only considered provisioned concurrency. In practice, you can set both provisioned
        concurrency and reserved concurrency on a function. You might do this if you had a function that handles a
        consistent load of invocations, but routinely sees spikes of traffic during the weekends. In this case,
        you could use provisioned concurrency to set a baseline amount of environments to handle request during
        weekdays, and use reserved concurrency to handle the weekend spikes. Consider the following diagram:</p>
      <div class="mediaobject">
         
          <img src="/images/lambda/latest/dg/images/concurrency-9-reserved-and-provisioned.png" class="aws-docs-img-whiteBg aws-docs-img-padding" alt="&#xA;          Function scaling behavior when you use both reserved and provisioned concurrency.&#xA;        " style="max-width:100%" />
         
         
      </div>
      <p>In this diagram, suppose that you configure 200 units of provisioned concurrency and 400 units of
        reserved concurrency for <code class="code">function-orange</code>. Because you configured reserved concurrency,
        <code class="code">function-orange</code> cannot use any of the 600 units of unreserved concurrency.</p>
      <p>This diagram has 5 points of interest:</p>
      <div class="itemizedlist">
         
         
         
         
         
      <ul class="itemizedlist"><li class="listitem">
          <p>At <code class="code">t1</code>, <code class="code">function-orange</code> begins receiving requests. Since Lambda has
            pre-initialized 200 execution environment instances, <code class="code">function-orange</code> is ready for
            immediate invocation.</p>
        </li><li class="listitem">
          <p>At <code class="code">t2</code>, <code class="code">function-orange</code> uses up all its provisioned concurrency.
            <code class="code">function-orange</code> can continue serving requests using reserved concurrency, but these
            requests may experience cold start latencies.</p>
        </li><li class="listitem">
          <p>At <code class="code">t3</code>, <code class="code">function-orange</code> reaches 400 concurrent requests. As a result,
            <code class="code">function-orange</code> uses up all its reserved concurrency. Since <code class="code">function-orange</code>
            cannot use unreserved concurrency, requests begin to throttle.</p>
        </li><li class="listitem">
          <p>At <code class="code">t4</code>, <code class="code">function-orange</code> starts to receive fewer requests, and no longer
            throttles.</p>
        </li><li class="listitem">
          <p>At <code class="code">t5</code>, <code class="code">function-orange</code> drops down to 200 concurrent requests, so all
            requests are again able to use provisioned concurrency (i.e. no cold start latencies).</p>
        </li></ul></div>
      <p>Both reserved concurrency and provisioned concurrency count towards your account concurrency limit
        and <a href="https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-limits.html">Regional quotas</a>.
        In other words, allocating reserved and provisioned concurrency can impact the concurrency pool that's
        available to other functions. Configuring provisioned concurrency incurs charges to your AWS account.</p>
      <div class="awsdocs-note"><div class="awsdocs-note-title"><awsui-icon name="status-info" variant="link"></awsui-icon><h6>Note</h6></div><div class="awsdocs-note-text"><p>If the amount of provisioned concurrency on a function's versions and aliases adds up to the
        function's reserved concurrency, all invocations run on provisioned concurrency. This configuration also
        has the effect of throttling the unpublished version of the function (<code class="code">$LATEST</code>), which
        prevents it from executing. You can't allocate more provisioned concurrency than reserved concurrency
        for a function.</p></div></div>
      <p>To manage provisioned concurrency settings for your functions, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/provisioned-concurrency.html">configuring provisioned concurrency</a>. To
        automate provisioned concurrency scaling based on a schedule or application utilization, see
        <a href="https://docs.aws.amazon.com/lambda/latest/dg/provisioned-concurrency.html#managing-provisioned-concurency">
        managing provisioned concurrency with Application Auto Scaling</a>.</p>
     
     
      <h3 id="allocating-provisioned-concurrency">How Lambda allocates provisioned concurrency</h3>
      <p>Provisioned concurrency doesn't come online immediately after you configure it. Lambda starts
        allocating provisioned concurrency after a minute or two of preparation. In particular, Lambda
        can provision between 500 to 3,000 execution environments at once, depending on the region.
        After this initial burst, Lambda allocates 500 additional environments per minute, regardless
        of the region, until the request is fulfilled.</p>
      <p>For example, suppose your account concurrency limit is 10,000. Also, suppose that at 10:00
        in US East (N. Virginia), you configure 5,000 units of provisioned concurrency for one function.
        Here's how Lambda might allocate provisioned concurrency units:</p>
      <div class="mediaobject">
         
          <img src="/images/lambda/latest/dg/images/provisioned-concurrency-allocation.png" class="aws-docs-img-whiteBg aws-docs-img-padding" alt="&#xA;          A line graph showing how Lambda allocates provisioned concurrency instances.&#xA;        " style="max-width:100%" />
         
         
      </div>
      <p>In the previous diagram:</p>
      <div class="itemizedlist">
         
         
         
         
      <ul class="itemizedlist"><li class="listitem">
          <p>Initially, Lambda can provision at max 3,000 execution environments, since the
            initial burst concurrency limit in US East (N. Virginia) is 3,000.</p>
        </li><li class="listitem">
          <p><b>At 10:00</b>: You request 5,000 units of provisioned
            concurrency for this function. Lambda doesn't begin provisioning execution environments
            instantaneously.</p>
        </li><li class="listitem">
          <p><b>At 10:01</b>: Lambda starts by provisioning 3,000
            environments.</p>
        </li><li class="listitem">
          <p><b>From 10:02 to 10:05</b>: Lambda provisions 500
            additional environments each minute. By 10:05, Lambda finishes allocating 5,000
            environments to your function.</p>
        </li></ul></div>
      <p>When you submit a request to allocate provisioned concurrency, you can't access
        any of those environments until Lambda completely finishes allocating them. For example,
        in the previous scenario, none of your requests can use provisioned concurrency until
        10:05, since that's when Lambda completely finishes allocating your request of 5,000
        execution environments.</p>
     
     
      <h3 id="comparing-reserved-provisioned">Comparing reserved concurrency and provisioned concurrency</h3>
      <p>The following is a table summarizing and comparing reserved and provisioned concurrency.</p>
      <div class="table-container"><div class="table-contents"><table id="w917aac35c17c15c15b5"><thead>
            <tr>
              <th>Topic</th>
              <th>Reserved concurrency</th>
              <th>Provisioned concurrency</th>
            </tr>
          </thead>
            <tr>
              <td tabindex="-1">
                <p>Definition</p>
              </td>
              <td tabindex="-1">
                <p>Maximum number of execution environment instances for your function.</p>
              </td>
              <td tabindex="-1">
                <p>Set number of pre-provisioned execution environment instances for your function.</p>
              </td>
            </tr>
            <tr>
              <td tabindex="-1">
                <p>Provisioning behavior</p>
              </td>
              <td tabindex="-1">
                <p>Lambda provisions new instances on an on-demand basis.</p>
              </td>
              <td tabindex="-1">
                <p>Lambda pre-provisions instances (i.e. before your function starts receiving requests).</p>
              </td>
            </tr>
            <tr>
              <td tabindex="-1">
                <p>Cold start behavior</p>
              </td>
              <td tabindex="-1">
                <p>Cold start latency possible, since Lambda must create new instances on-demand.</p>
              </td>
              <td tabindex="-1">
                <p>Cold start latency eliminated, since Lambda doesn't have to create instances on-demand.</p>
              </td>
            </tr>
            <tr>
              <td tabindex="-1">
                <p>Throttling behavior</p>
              </td>
              <td tabindex="-1">
                <p>Function throttled when reserved concurrency limit reached.</p>
              </td>
              <td tabindex="-1">
                <p>If reserved concurrency not set: function uses unreserved concurrency when provisioned concurrency
                  limit reached.</p>
                <p>If reserved concurrency set: function throttled when reserved concurrency limit reached.</p>
              </td>
            </tr>
            <tr>
              <td tabindex="-1">
                <p>Default behavior if not set</p>
              </td>
              <td tabindex="-1">
                <p>Function uses unreserved concurrency available in your account.</p>
              </td>
              <td tabindex="-1">
                <p>Lambda doesn't pre-provision any instances. Instead, if reserved concurrency not set: function uses
                  unreserved concurrency available in your account.</p>
                <p>If reserved concurrency set: function uses reserved concurrency.</p>
              </td>
            </tr>
            <tr>
              <td tabindex="-1">
                <p>Pricing</p>
              </td>
              <td tabindex="-1">
                <p>No additional charge.</p>
              </td>
              <td tabindex="-1">
                <p>Incurs additional charges.</p>
              </td>
            </tr>
          </table></div></div>
     
   
    <h2 id="concurrency-quotas">Concurrency quotas</h2>
    <p>Lambda sets quotas for the total amount of concurrency you can use across all functions in a region. These quotas
      exist on two levels:</p>
    <div class="itemizedlist">
       
       
    <ul class="itemizedlist"><li class="listitem">
        <p><b>At the account level</b>, your functions can have up to 1,000 units of concurrency
          by default. To increase this limit, see <a href="https://docs.aws.amazon.com/servicequotas/latest/userguide/request-quota-increase.html">Requesting a quota increase</a> in the
          <em>Service Quotas User Guide</em>.</p>
      </li><li class="listitem">
        <p><b>At the function level</b>, you can reserve up to 900 units of concurrency across
          all your functions by default. 100 units of concurrency are always reserved for functions that don't explicitly
          reserve concurrency. For example, if you increased your account concurrency limit to 2,000, you can reserve up
          to 1,900 units of concurrency at the function level.</p>
      </li></ul></div>
    <p>To check your current account level concurrency quota, use the AWS Command Line Interface (CLI) to run the following command:</p>
    <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class="">aws lambda get-account-settings</code></pre>
    <p>You should see output that looks like the following:</p>
    <pre class="programlisting"><div class="code-btn-container"><div class="btn-copy-code" title="Copy"><awsui-icon name="copy"></awsui-icon></div></div><code class=""><span>{</span>
    "AccountLimit": <span>{</span>
        "TotalCodeSize": 80530636800,
        "CodeSizeUnzipped": 262144000,
        "CodeSizeZipped": 52428800,
        "ConcurrentExecutions": 1000,
        "UnreservedConcurrentExecutions": 900
    },
    "AccountUsage": <span>{</span>
        "TotalCodeSize": 410759889,
        "FunctionCount": 8
    }
}
</code></pre>
    <p><code class="code">ConcurrentExecutions</code> is your total account level concurrency quota.
      <code class="code">UnreservedConcurrentExecutions</code> is the amount of reserved concurrency you can still allocate to your
      functions.</p>
    <p>For initial bursts of traffic, your cumulative concurrency can reach a level of between 500 and 3,000
      depending on the region:</p>
    <div class="table-container"><div class="table-contents"><table id="w917aac35c17c17c19"><thead>
          <tr>
            <th>Regions</th>
            <th>Burst concurrency limit</th>
          </tr>
        </thead>
          <tr>
            <td tabindex="-1">
              <p>US West (Oregon), US East (N. Virginia), Europe (Ireland)</p>
            </td>
            <td tabindex="-1">
              <p>3,000</p>
            </td>
          </tr>
          <tr>
            <td tabindex="-1">
              <p>Asia Pacific (Tokyo), Europe (Frankfurt), US East (Ohio)</p>
            </td>
            <td tabindex="-1">
              <p>1,000</p>
            </td>
          </tr>
          <tr>
            <td tabindex="-1">
              <p>All other Regions</p>
            </td>
            <td tabindex="-1">
              <p>500</p>
            </td>
          </tr>
        </table></div></div>
    <p>After the initial burst increase, Lambda continues to scale up your function based
      on the following rules:</p>
    <div class="itemizedlist">
       
       
    <ul class="itemizedlist"><li class="listitem">
        <p>If your function needs additional scaling, Lambda can scale up by a maximum of
          500 additional execution environment instances (burst quota units) per minute,
          regardless of the Region.</p>
      </li><li class="listitem">
        <p>Each minute, you continue to accrue 500 burst quota units. If your function
          doesnt require this level of scaling, Lambda saves up any unused units in an
          imaginary bucket, up until the bucket reaches the maximum burst concurrency
          limit in your Region. For instance, your bucket can continue to accrue 500 units
          per minute until it reaches 3,000 units in US East (N. Virginia). When your
          function encounters future bursts, Lambda draws from your bucket to scale up
          your function.</p>
      </li></ul></div>
    <p>For more information, see <a href="./burst-concurrency.html">Burst concurrency</a>. If you need a burst concurrency limit increase,
      please inquire further through AWS Support. Service Quotas do not support changes in burst limits at this time.</p>
  <awsdocs-copyright class="copyright-print"></awsdocs-copyright><awsdocs-thumb-feedback right-edge="{{$ctrl.thumbFeedbackRightEdge}}"></awsdocs-thumb-feedback></div><noscript><div><div><div><div id="js_error_message"><p><img src="https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png" alt="Warning" /> <strong>Javascript is disabled or is unavailable in your browser.</strong></p><p>To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.</p></div></div></div></div></noscript><div id="main-col-footer" class="awsui-util-font-size-0"><div id="doc-conventions"><a target="_top" href="/general/latest/gr/docconventions.html">Document Conventions</a></div><div class="prev-next"><div id="previous" class="prev-link" accesskey="p" href="./gettingstarted-awscli.html">Tutorial - Lambda with CLI</div><div id="next" class="next-link" accesskey="n" href="./configuration-concurrency.html">Configuring reserved concurrency</div></div></div><awsdocs-page-utilities></awsdocs-page-utilities></div><div id="quick-feedback-yes" style="display: none;"><div class="title">Did this page help you? - Yes</div><div class="content"><p>Thanks for letting us know we're doing a good job!</p><p>If you've got a moment, please tell us what we did right so we can do more of it.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Lambda&amp;topic_url=https://docs.aws.amazon.com/en_us/lambda/latest/dg/lambda-concurrency.html"></awsui-button></p></div></div><div id="quick-feedback-no" style="display: none;"><div class="title">Did this page help you? - No</div><div class="content"><p>Thanks for letting us know this page needs work. We're sorry we let you down.</p><p>If you've got a moment, please tell us how we can make the documentation better.</p><p><awsui-button id="fblink" rel="noopener noreferrer" target="_blank" text="Feedback" click="linkClick($event)" href="https://docs.aws.amazon.com/forms/aws-doc-feedback?hidden_service_name=Lambda&amp;topic_url=https://docs.aws.amazon.com/en_us/lambda/latest/dg/lambda-concurrency.html"></awsui-button></p></div></div></div></body></div></awsdocs-view><div class="page-loading-indicator" id="page-loading-indicator"><awsui-spinner size="large"></awsui-spinner></div></div><div id="tools-panel" dom-region="tools"><awsdocs-tools-panel id="awsdocs-tools-panel"></awsdocs-tools-panel></div></awsui-app-layout><awsdocs-cookie-banner class="doc-cookie-banner"></awsdocs-cookie-banner></div></body></html>